<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go-Redis</title>
      <link href="/2025/06/03/go-redis/"/>
      <url>/2025/06/03/go-redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-的使用"><a href="#Redis-的使用" class="headerlink" title="Redis 的使用"></a>Redis 的使用</h1><p>Redis 是一个开源的（BSD 许可）内存数据结构存储，可用作数据库、缓存和消息代理。它支持多种数据结构，如字符串、哈希、列表、集合、有序集合等。在 Gin 框架中集成 Redis 可以极大地提高应用程序的性能和可扩展性。</p><p>本教程将介绍如何在 Gin 应用程序中连接 Redis、进行基本操作（如设置和获取键值）、以及如何使用 Redis 进行会话管理和缓存。</p><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><p>在开始之前，请确保您的开发环境已准备就绪。</p><h3 id="1-1-安装-Go-Redis-客户端"><a href="#1-1-安装-Go-Redis-客户端" class="headerlink" title="1.1 安装 Go Redis 客户端"></a>1.1 安装 Go Redis 客户端</h3><p>我们将使用 <code>go-redis/redis/v8</code> 库作为 Redis 客户端。它是 Go 语言中最流行和功能最丰富的 Redis 客户端之一。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/go-redis/redis/v8</span><br></pre></td></tr></table></figure><h3 id="1-2-安装和运行-Redis-服务器"><a href="#1-2-安装和运行-Redis-服务器" class="headerlink" title="1.2 安装和运行 Redis 服务器"></a>1.2 安装和运行 Redis 服务器</h3><p>您可以通过多种方式安装和运行 Redis 服务器：</p><ul><li><p><strong>Docker (推荐)</strong>：最简单快捷的方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run --name my-redis -p 6379:6379 -d redis/redis-stack-server:latest</span><br><span class="line">    <span class="comment"># 或者只运行 Redis 核心</span></span><br><span class="line">    <span class="comment"># docker run --name my-redis -p 6379:6379 -d redis:latest</span></span><br></pre></td></tr></table></figure><p>这将启动一个名为 <code>my-redis</code> 的 Redis 容器，并将容器的 6379 端口映射到主机的 6379 端口。</p></li><li><p><strong>手动安装</strong>：</p><ul><li><strong>macOS (Homebrew)</strong>: <code>brew install redis</code></li><li><strong>Linux (apt&#x2F;yum)</strong>: <code>sudo apt update &amp;&amp; sudo apt install redis-server</code> 或 <code>sudo yum install redis</code></li><li><strong>Windows</strong>: 可以从官方网站下载或使用 WSL2。</li></ul></li></ul><p>安装完成后，确保 Redis 服务器正在运行（默认监听 6379 端口）。您可以使用 <code>redis-cli ping</code> 来测试连接。如果返回 <code>PONG</code> 则表示连接成功。</p><h3 id="1-3-Redis-配置修改-Windows"><a href="#1-3-Redis-配置修改-Windows" class="headerlink" title="1.3 Redis 配置修改 (Windows)"></a>1.3 Redis 配置修改 (Windows)</h3><p>在 Windows 系统中，Redis 通常以服务形式运行或通过命令行手动启动。它的行为通过 <strong><code>redis.windows.conf</code></strong> 文件进行配置。</p><h4 id="1-3-1-找到-Redis-配置文件"><a href="#1-3-1-找到-Redis-配置文件" class="headerlink" title="1.3.1 找到 Redis 配置文件"></a>1.3.1 找到 Redis 配置文件</h4><p>如果您是手动安装 Redis for Windows，<code>redis.windows.conf</code> 文件通常位于您解压 Redis 安装包的根目录下。</p><p>例如：<code>C:\Program Files\Redis\redis.windows.conf</code> 或 <code>C:\redis-x.x.x\redis.windows.conf</code>。</p><p>找到文件后，使用记事本、Notepad++ 或 VS Code 等文本编辑器打开它。</p><h4 id="1-3-2-主要配置项更改"><a href="#1-3-2-主要配置项更改" class="headerlink" title="1.3.2 主要配置项更改"></a>1.3.2 主要配置项更改</h4><p>以下是一些您可能会经常更改或需要注意的重要配置项及其修改建议。请根据您的需求取消注释（删除行首的 <code>#</code>）并修改对应的值。</p><ul><li><p><strong><code>bind</code></strong></p><ul><li><p><strong>作用</strong>：指定 Redis 服务器监听的 IP 地址。</p></li><li><p>修改：默认情况下，Redis for Windows 可能没有明确的 <code>bind</code> 设置，或者它会监听所有可用接口。如果您需要限制访问，可以将其设置为特定 IP 地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># bind 127.0.0.1           # 默认可能没有这一行，或只监听本地</span><br><span class="line">bind 0.0.0.0               # 监听所有可用 IP (仅用于测试，生产环境请谨慎)</span><br></pre></td></tr></table></figure></li><li><p><strong>重要提示</strong>：在没有密码或防火墙保护的情况下，将 <code>bind</code> 设置为 <code>0.0.0.0</code> 并暴露在公网是非常危险的。</p></li></ul></li><li><p><strong><code>port</code></strong></p><ul><li><p><strong>作用</strong>：指定 Redis 服务器监听的 TCP 端口。</p></li><li><p>修改：如果您希望 Redis 监听非标准端口，可以在此修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port 6379 # 保持默认或修改为其他端口，如 6380</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>protected-mode</code></strong></p><ul><li><p><strong>作用</strong>：保护模式，在没有 <code>bind</code> 设置和 <code>requirepass</code>（密码）设置的情况下，只允许本地回环地址（127.0.0.1）访问。</p></li><li><p>修改：强烈建议保持为 <code>yes</code>。如果您需要从外部连接且不设置密码（不推荐），则必须将其设置为 <code>no</code>，但同时需要设置 Windows 防火墙规则来限制访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected-mode yes</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>requirepass</code></strong></p><ul><li><p><strong>作用</strong>：设置 Redis 连接密码。</p></li><li><p>修改：**在生产环境中，强烈建议设置一个强密码。**取消注释并替换 <code>foobared</code> 为您的密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass your_strong_password_here # 设置您的密码</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>databases</code></strong></p><ul><li><p><strong>作用</strong>：设置可用的数据库数量。Redis 默认有 16 个数据库，索引从 0 到 15。</p></li><li><p>修改：通常默认值已足够，根据您的应用程序需求调整。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">databases 16</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>maxmemory</code></strong></p><ul><li><p><strong>作用</strong>：设置 Redis 可用的最大内存量。当达到此限制时，Redis 将根据 <code>maxmemory-policy</code> 配置来决定如何处理新数据。</p></li><li><p>修改：在生产环境中，强烈建议设置此项，以防止 Redis 使用过多内存导致系统不稳定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maxmemory 2gb # 设置最大内存为 2GB</span><br><span class="line"># 当达到 maxmemory 限制时，优先删除带有过期时间的键，并且删除最少使用的键</span><br><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>daemonize</code></strong></p><ul><li><p><strong>作用</strong>：在 Linux&#x2F;macOS 上，这会使 Redis 作为守护进程（后台进程）运行。在 Windows 上，这个设置通常<strong>不生效</strong>或行为不同，因为 Windows 服务或控制台程序有自己的后台机制。如果您是通过 <code>redis-server.exe</code> 直接运行，它通常会占用控制台窗口。如果您将其作为服务安装，则由服务管理器控制后台运行。</p></li><li><p>修改</p><p>：通常无需在 Windows 下修改此项，保持 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no</span><br></pre></td></tr></table></figure><p> 即可。</p><p>代码段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize no</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>loglevel</code></strong></p><ul><li><p><strong>作用</strong>：设置日志级别。可选值有 <code>debug</code>, <code>verbose</code>, <code>notice</code>, <code>warning</code>。</p></li><li><p>修改</p><p>：开发&#x2F;调试阶段可以设置为 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug</span><br></pre></td></tr></table></figure><p> 或 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verbose</span><br></pre></td></tr></table></figure><p>生产环境通常设置为 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notice</span><br></pre></td></tr></table></figure><p> 或 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning</span><br></pre></td></tr></table></figure><p>，以减少日志量。</p><p>代码段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loglevel notice</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h4 id="1-3-3-重启-Redis-Windows"><a href="#1-3-3-重启-Redis-Windows" class="headerlink" title="1.3.3 重启 Redis (Windows)"></a>1.3.3 重启 Redis (Windows)</h4><p>修改配置文件后，您需要重启 Redis 服务器以使更改生效。重启方式取决于您如何在 Windows 上运行 Redis。</p><h5 id="1-3-3-1-作为-Windows-服务运行"><a href="#1-3-3-1-作为-Windows-服务运行" class="headerlink" title="1.3.3.1 作为 Windows 服务运行"></a>1.3.3.1 作为 Windows 服务运行</h5><p>如果您的 Redis 实例是作为 Windows 服务安装并运行的（这是推荐的生产环境部署方式），可以通过 Windows 的服务管理器来重启：</p><ol><li>按下 <code>Win + R</code> 键，输入 <code>services.msc</code>，然后按回车键打开 <strong>服务</strong> 管理器。</li><li>在服务列表中找到名为 <strong><code>Redis</code></strong> 或类似名称（例如 <code>Redis6379</code>）的服务。</li><li>右键点击该服务，然后选择 <strong>重启</strong>。</li></ol><h5 id="1-3-3-2-通过命令行手动运行"><a href="#1-3-3-2-通过命令行手动运行" class="headerlink" title="1.3.3.2 通过命令行手动运行"></a>1.3.3.2 通过命令行手动运行</h5><p>如果您是通过命令行直接运行 <code>redis-server.exe</code>，您需要先停止当前的进程，然后重新启动它：</p><ol><li><p><strong>停止当前 Redis 进程：</strong></p><ul><li><p>打开一个新的命令提示符 (CMD) 或 PowerShell 窗口。</p></li><li><p>使用 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli.exe</span><br></pre></td></tr></table></figure><p> 连接到您的 Redis 实例并发送 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHUTDOWN</span><br></pre></td></tr></table></figure><p> 命令。</p><p>DOS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli.exe -h 127.0.0.1 -p 6379 SHUTDOWN</span><br></pre></td></tr></table></figure><ul><li><p>如果设置了密码，请添加 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-a</span><br></pre></td></tr></table></figure><p> 参数：</p><p>DOS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli.exe -h 127.0.0.1 -p 6379 -a your_password SHUTDOWN</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果 Redis 运行在控制台窗口中，发送 <code>SHUTDOWN</code> 命令后，该控制台窗口通常会自动关闭。</p></li></ul></li><li><p><strong>使用更新后的配置文件启动 Redis 服务器：</strong></p><ul><li><p>打开一个新的命令提示符 (CMD) 或 PowerShell 窗口。</p></li><li><p>导航到 <code>redis-server.exe</code> 所在的目录。</p></li><li><p>执行以下命令，指定您的配置文件路径：</p><p>DOS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br><span class="line"># 或如果配置文件在其他路径：</span><br><span class="line"># redis-server.exe C:\path\to\your\redis.windows.conf</span><br></pre></td></tr></table></figure></li><li><p>这将会在当前控制台窗口中启动 Redis。如果您想让它在后台运行（不占用控制台），可以考虑使用 <code>start</code> 命令（但通常建议安装为服务）。</p></li></ul></li></ol><p>重启后，您可以使用 <code>redis-cli.exe</code> 连接到 Redis 并执行 <code>PING</code> 命令或 <code>CONFIG GET &lt;config_name&gt;</code> 命令来验证新的配置是否已生效。</p><h2 id="2-基本-Redis-操作"><a href="#2-基本-Redis-操作" class="headerlink" title="2. 基本 Redis 操作"></a>2. 基本 Redis 操作</h2><p>在使用 Gin 之前，我们先了解 <code>go-redis</code> 库的基本操作。</p><h3 id="2-1-连接-Redis"><a href="#2-1-连接-Redis" class="headerlink" title="2.1 连接 Redis"></a>2.1 连接 Redis</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/go-redis/redis/v8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ctx = context.Background()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建 Redis 客户端实例</span></span><br><span class="line">rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr:     <span class="string">&quot;localhost:6379&quot;</span>, <span class="comment">// Redis 服务器地址</span></span><br><span class="line">Password: <span class="string">&quot;&quot;</span>,               <span class="comment">// 如果有密码，请填写</span></span><br><span class="line">DB:       <span class="number">0</span>,                <span class="comment">// 数据库索引，默认为 0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// PING 命令检查连接</span></span><br><span class="line">pong, err := rdb.Ping(ctx).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error connecting to Redis:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Redis connected:&quot;</span>, pong) <span class="comment">// 应该输出 PONG</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-设置和获取字符串"><a href="#2-2-设置和获取字符串" class="headerlink" title="2.2 设置和获取字符串"></a>2.2 设置和获取字符串</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/go-redis/redis/v8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ctx = context.Background()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr: <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">DB:   <span class="number">0</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个键值对</span></span><br><span class="line">err := rdb.Set(ctx, <span class="string">&quot;mykey&quot;</span>, <span class="string">&quot;Hello Redis from Go!&quot;</span>, <span class="number">0</span>).Err() <span class="comment">// 0 表示永不过期</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error setting key:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Key &#x27;mykey&#x27; set successfully.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键的值</span></span><br><span class="line">val, err := rdb.Get(ctx, <span class="string">&quot;mykey&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err == redis.Nil &#123; <span class="comment">// 如果键不存在</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Key &#x27;mykey&#x27; does not exist.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error getting key:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Value of &#x27;mykey&#x27;:&quot;</span>, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除键</span></span><br><span class="line">_, err = rdb.Del(ctx, <span class="string">&quot;mykey&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error deleting key:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Key &#x27;mykey&#x27; deleted successfully.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次尝试获取已删除的键</span></span><br><span class="line">val, err = rdb.Get(ctx, <span class="string">&quot;mykey&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Key &#x27;mykey&#x27; is now deleted.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-设置过期时间"><a href="#2-3-设置过期时间" class="headerlink" title="2.3 设置过期时间"></a>2.3 设置过期时间</h3><p>Redis 可以为键设置过期时间，使其在一段时间后自动删除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/go-redis/redis/v8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ctx = context.Background()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr: <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">DB:   <span class="number">0</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个带过期时间的键 (5 秒后过期)</span></span><br><span class="line">err := rdb.Set(ctx, <span class="string">&quot;expire_key&quot;</span>, <span class="string">&quot;This key will expire.&quot;</span>, <span class="number">5</span>*time.Second).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error setting key with expiry:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Key &#x27;expire_key&#x27; set with 5s expiry.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即获取</span></span><br><span class="line">val, _ := rdb.Get(ctx, <span class="string">&quot;expire_key&quot;</span>).Result()</span><br><span class="line">fmt.Println(<span class="string">&quot;Initial value of &#x27;expire_key&#x27;:&quot;</span>, val)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 6 秒，让键过期</span></span><br><span class="line">time.Sleep(<span class="number">6</span> * time.Second)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次获取，应该已经过期</span></span><br><span class="line">val, err = rdb.Get(ctx, <span class="string">&quot;expire_key&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Key &#x27;expire_key&#x27; has expired.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error getting expired key:&quot;</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Value of &#x27;expire_key&#x27; (should be expired):&quot;</span>, val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-在-Gin-中集成-Redis"><a href="#3-在-Gin-中集成-Redis" class="headerlink" title="3. 在 Gin 中集成 Redis"></a>3. 在 Gin 中集成 Redis</h2><p>现在我们将把 Redis 功能集成到 Gin 应用程序中。</p><h3 id="3-1-初始化-Redis-客户端"><a href="#3-1-初始化-Redis-客户端" class="headerlink" title="3.1 初始化 Redis 客户端"></a>3.1 初始化 Redis 客户端</h3><p>在 Gin 应用程序启动时，最好只初始化一次 Redis 客户端，并将其作为依赖注入到处理函数中，或者存储在一个全局变量中（但推荐依赖注入）。</p><p>我们通常将 Redis 客户端实例存储在 Gin 的 <code>gin.Context</code> 中，或者作为自定义结构体的字段传递。</p><p><strong><code>main.go</code></strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/go-redis/redis/v8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局的 Redis 客户端变量 (或者通过依赖注入)</span></span><br><span class="line"><span class="keyword">var</span> Rdb *redis.Client</span><br><span class="line"><span class="keyword">var</span> Ctx = context.Background()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initRedis</span><span class="params">()</span></span> &#123;</span><br><span class="line">Rdb = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr:     <span class="string">&quot;localhost:6379&quot;</span>, <span class="comment">// Redis 服务器地址</span></span><br><span class="line">Password: <span class="string">&quot;&quot;</span>,               <span class="comment">// 如果有密码，请填写</span></span><br><span class="line">DB:       <span class="number">0</span>,                <span class="comment">// 数据库索引</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试连接</span></span><br><span class="line">pong, err := Rdb.Ping(Ctx).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Could not connect to Redis: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Connected to Redis:&quot;</span>, pong)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 初始化 Redis 客户端</span></span><br><span class="line">initRedis()</span><br><span class="line"></span><br><span class="line">router := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 Redis 相关的路由</span></span><br><span class="line">router.GET(<span class="string">&quot;/set/:key/:value&quot;</span>, setKeyValue)</span><br><span class="line">router.GET(<span class="string">&quot;/get/:key&quot;</span>, getKeyValue)</span><br><span class="line">router.DELETE(<span class="string">&quot;/delete/:key&quot;</span>, deleteKey)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Gin server running on :8080&quot;</span>)</span><br><span class="line">router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-创建-Gin-路由处理-Redis-操作"><a href="#3-2-创建-Gin-路由处理-Redis-操作" class="headerlink" title="3.2 创建 Gin 路由处理 Redis 操作"></a>3.2 创建 Gin 路由处理 Redis 操作</h3><p>接下来，我们将为 Redis 操作创建 Gin 的路由处理函数。</p><p><strong><code>main.go</code> (续)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setKeyValue 处理 /set/:key/:value 路由，将键值对存储到 Redis</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setKeyValue</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">key := c.Param(<span class="string">&quot;key&quot;</span>)</span><br><span class="line">value := c.Param(<span class="string">&quot;value&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置键值对，并设置 1 分钟过期时间</span></span><br><span class="line">err := Rdb.Set(Ctx, key, value, <span class="number">1</span>*time.Minute).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusInternalServerError, gin.H&#123;<span class="string">&quot;error&quot;</span>: fmt.Sprintf(<span class="string">&quot;Failed to set key: %v&quot;</span>, err)&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: fmt.Sprintf(<span class="string">&quot;Key &#x27;%s&#x27; set successfully with value &#x27;%s&#x27;&quot;</span>, key, value)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getKeyValue 处理 /get/:key 路由，从 Redis 获取键的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getKeyValue</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">key := c.Param(<span class="string">&quot;key&quot;</span>)</span><br><span class="line"></span><br><span class="line">val, err := Rdb.Get(Ctx, key).Result()</span><br><span class="line"><span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">c.JSON(http.StatusNotFound, gin.H&#123;<span class="string">&quot;error&quot;</span>: fmt.Sprintf(<span class="string">&quot;Key &#x27;%s&#x27; not found&quot;</span>, key)&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusInternalServerError, gin.H&#123;<span class="string">&quot;error&quot;</span>: fmt.Sprintf(<span class="string">&quot;Failed to get key: %v&quot;</span>, err)&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;key&quot;</span>: key, <span class="string">&quot;value&quot;</span>: val&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deleteKey 处理 /delete/:key 路由，从 Redis 删除键</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteKey</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">key := c.Param(<span class="string">&quot;key&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Del 方法返回受影响的键数量</span></span><br><span class="line">deleted, err := Rdb.Del(Ctx, key).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusInternalServerError, gin.H&#123;<span class="string">&quot;error&quot;</span>: fmt.Sprintf(<span class="string">&quot;Failed to delete key: %v&quot;</span>, err)&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> deleted == <span class="number">0</span> &#123;</span><br><span class="line">c.JSON(http.StatusNotFound, gin.H&#123;<span class="string">&quot;message&quot;</span>: fmt.Sprintf(<span class="string">&quot;Key &#x27;%s&#x27; not found or already deleted&quot;</span>, key)&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: fmt.Sprintf(<span class="string">&quot;Key &#x27;%s&#x27; deleted successfully&quot;</span>, key)&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-处理错误"><a href="#3-3-处理错误" class="headerlink" title="3.3 处理错误"></a>3.3 处理错误</h3><p>在实际应用中，处理 Redis 操作可能出现的错误至关重要。<code>go-redis</code> 库在键不存在时会返回 <code>redis.Nil</code> 错误，其他网络或 Redis 服务器错误则会返回不同的错误类型。务必对这些错误进行检查和处理。</p><h2 id="4-使用-Redis-作为缓存"><a href="#4-使用-Redis-作为缓存" class="headerlink" title="4. 使用 Redis 作为缓存"></a>4. 使用 Redis 作为缓存</h2><p>Redis 最常见的用途之一是作为应用程序的缓存层。我们可以创建一个 Gin 中间件来实现简单的缓存功能。</p><h3 id="4-1-实现缓存中间件"><a href="#4-1-实现缓存中间件" class="headerlink" title="4.1 实现缓存中间件"></a>4.1 实现缓存中间件</h3><p>这个中间件将尝试从 Redis 获取响应，如果命中缓存，则直接返回；如果未命中，则继续执行后续处理函数，并将结果缓存起来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/go-redis/redis/v8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... (initRedis, Rdb, Ctx declarations from previous section)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CacheMiddleware 是一个简单的缓存中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CacheMiddleware</span><span class="params">(cacheDuration time.Duration)</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 生成缓存键：通常使用请求的 URL 或更复杂的哈希</span></span><br><span class="line">cacheKey := <span class="string">&quot;cache:&quot;</span> + c.Request.RequestURI</span><br><span class="line">log.Printf(<span class="string">&quot;Attempting to fetch from cache for key: %s\n&quot;</span>, cacheKey)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试从 Redis 获取缓存数据</span></span><br><span class="line">cachedResponse, err := Rdb.Get(Ctx, cacheKey).Result()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 缓存命中！直接返回缓存的数据</span></span><br><span class="line">log.Printf(<span class="string">&quot;Cache HIT for key: %s\n&quot;</span>, cacheKey)</span><br><span class="line">c.Header(<span class="string">&quot;X-Cache&quot;</span>, <span class="string">&quot;HIT&quot;</span>)</span><br><span class="line">c.Data(http.StatusOK, <span class="string">&quot;application/json&quot;</span>, []<span class="type">byte</span>(cachedResponse))</span><br><span class="line">c.Abort() <span class="comment">// 阻止后续处理函数执行</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Cache MISS for key: %s\n&quot;</span>, cacheKey)</span><br><span class="line">c.Header(<span class="string">&quot;X-Cache&quot;</span>, <span class="string">&quot;MISS&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error getting from Redis cache: %v\n&quot;</span>, err)</span><br><span class="line"><span class="comment">// 如果 Redis 出错，不阻止请求继续执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个响应写入器，捕获响应内容</span></span><br><span class="line">blw := &amp;bodyLogWriter&#123;body: bytes.NewBufferString(<span class="string">&quot;&quot;</span>), ResponseWriter: c.Writer&#125;</span><br><span class="line">c.Writer = blw</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续处理请求</span></span><br><span class="line">c.Next()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查状态码，只缓存成功的响应 (200 OK)</span></span><br><span class="line"><span class="keyword">if</span> c.Writer.Status() == http.StatusOK &#123;</span><br><span class="line"><span class="comment">// 将响应内容缓存到 Redis</span></span><br><span class="line">err = Rdb.Set(Ctx, cacheKey, blw.body.String(), cacheDuration).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error setting Redis cache: %v\n&quot;</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Response cached for key: %s, duration: %s\n&quot;</span>, cacheKey, cacheDuration)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bodyLogWriter 是一个自定义的 ResponseWriter，用于捕获响应体</span></span><br><span class="line"><span class="keyword">type</span> bodyLogWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">gin.ResponseWriter</span><br><span class="line">body *bytes.Buffer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w bodyLogWriter)</span></span> Write(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">w.body.Write(b)</span><br><span class="line"><span class="keyword">return</span> w.ResponseWriter.Write(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w bodyLogWriter)</span></span> WriteString(s <span class="type">string</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">w.body.WriteString(s)</span><br><span class="line"><span class="keyword">return</span> w.ResponseWriter.WriteString(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 函数 (续)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">initRedis()</span><br><span class="line">router := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用全局 Logger 中间件</span></span><br><span class="line">router.Use(gin.Logger())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个带缓存的路由组</span></span><br><span class="line">cachedGroup := router.Group(<span class="string">&quot;/cached&quot;</span>)</span><br><span class="line"><span class="comment">// 将缓存中间件应用于此组，缓存 10 秒</span></span><br><span class="line">cachedGroup.Use(CacheMiddleware(<span class="number">10</span> * time.Second))</span><br><span class="line">&#123;</span><br><span class="line">cachedGroup.GET(<span class="string">&quot;/data&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Executing /cached/data handler (simulating slow operation)...&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 模拟一个耗时操作</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;data&quot;</span>: <span class="string">&quot;This is cached data!&quot;</span>, <span class="string">&quot;timestamp&quot;</span>: time.Now().Format(time.RFC3339)&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非缓存路由</span></span><br><span class="line">router.GET(<span class="string">&quot;/no-cache-data&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Executing /no-cache-data handler...&quot;</span>)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;data&quot;</span>: <span class="string">&quot;This data is not cached.&quot;</span>, <span class="string">&quot;timestamp&quot;</span>: time.Now().Format(time.RFC3339)&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Gin server running on :8080&quot;</span>)</span><br><span class="line">router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-在路由中使用缓存"><a href="#4-2-在路由中使用缓存" class="headerlink" title="4.2 在路由中使用缓存"></a>4.2 在路由中使用缓存</h3><p>在上面的例子中，我们已经演示了如何将 <code>CacheMiddleware</code> 应用到一个路由组 (<code>/cached</code>)。所有该组下的路由都会受益于缓存。</p><p><strong>测试缓存：</strong></p><ol><li>启动 Gin 服务器。</li><li>第一次访问 <code>http://localhost:8080/cached/data</code>：您会看到日志输出 <code>Executing /cached/data handler...</code> 和 <code>Cache MISS</code>，请求会延迟 2 秒。</li><li>在 10 秒内再次访问 <code>http://localhost:8080/cached/data</code>：您会看到日志输出 <code>Cache HIT</code>，请求会立即返回，且 <code>timestamp</code> 值与第一次相同（因为它返回的是缓存的数据）。</li><li>等待 10 秒以上，再次访问 <code>http://localhost:8080/cached/data</code>：缓存过期，您会再次看到 <code>Cache MISS</code> 和 2 秒延迟，<code>timestamp</code> 值会更新。</li><li>访问 <code>http://localhost:8080/no-cache-data</code>：每次访问都会立即返回，没有缓存。</li></ol><h2 id="5-高级用法（可选）"><a href="#5-高级用法（可选）" class="headerlink" title="5. 高级用法（可选）"></a>5. 高级用法（可选）</h2><h3 id="5-1-Redis-连接池"><a href="#5-1-Redis-连接池" class="headerlink" title="5.1 Redis 连接池"></a>5.1 Redis 连接池</h3><p><code>go-redis</code> 客户端本身就包含了连接池管理。在 <code>redis.NewClient</code> 中，您可以配置 <code>PoolSize</code>、<code>MinIdleConns</code> 等选项来优化连接池行为。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">    Addr:         <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">    Password:     <span class="string">&quot;&quot;</span>,</span><br><span class="line">    DB:           <span class="number">0</span>,</span><br><span class="line">    PoolSize:     <span class="number">10</span>,  <span class="comment">// 最大连接数</span></span><br><span class="line">    MinIdleConns: <span class="number">5</span>,   <span class="comment">// 最小空闲连接数</span></span><br><span class="line">    PoolTimeout:  <span class="number">30</span> * time.Second, <span class="comment">// 从连接池获取连接的超时时间</span></span><br><span class="line">    IdleTimeout:  <span class="number">5</span> * time.Minute,  <span class="comment">// 空闲连接的关闭时间</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5-2-使用-Redis-实现分布式锁"><a href="#5-2-使用-Redis-实现分布式锁" class="headerlink" title="5.2 使用 Redis 实现分布式锁"></a>5.2 使用 Redis 实现分布式锁</h3><p>当您有多个服务实例需要对共享资源进行互斥访问时，可以使用 Redis 实现分布式锁。<code>go-redis</code> 提供了 <code>SetNX</code>（Set if Not eXists）和 <code>Expire</code> 命令的封装，可以用来构建简单的锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/go-redis/redis/v8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObtainLock 尝试获取分布式锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ObtainLock</span><span class="params">(client *redis.Client, key <span class="type">string</span>, value <span class="type">string</span>, expiration time.Duration)</span></span> (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// SetNX 命令在键不存在时设置键值，并设置过期时间</span></span><br><span class="line"><span class="comment">// 如果设置成功，返回 true；如果键已存在，返回 false</span></span><br><span class="line">ok, err := client.SetNX(Ctx, key, value, expiration).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ok, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReleaseLock 释放分布式锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReleaseLock</span><span class="params">(client *redis.Client, key <span class="type">string</span>, value <span class="type">string</span>)</span></span> (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// 使用 Lua 脚本确保原子性：检查值是否匹配，然后删除键</span></span><br><span class="line"><span class="comment">// 这是为了防止 A 释放了 B 的锁</span></span><br><span class="line">script := <span class="string">`</span></span><br><span class="line"><span class="string">if redis.call(&quot;GET&quot;, KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">return redis.call(&quot;DEL&quot;, KEYS[1])</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">return 0</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">result, err := client.Eval(Ctx, script, []<span class="type">string</span>&#123;key&#125;, value).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result.(<span class="type">int64</span>) == <span class="number">1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Gin 路由中使用</span></span><br><span class="line"><span class="comment">// router.GET(&quot;/lock-resource&quot;, func(c *gin.Context) &#123;</span></span><br><span class="line"><span class="comment">//     lockKey := &quot;my_resource_lock&quot;</span></span><br><span class="line"><span class="comment">//     lockValue := &quot;unique_session_id_123&quot; // 建议使用 UUID 或其他唯一标识</span></span><br><span class="line"><span class="comment">//     lockTTL := 10 * time.Second</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     locked, err := ObtainLock(Rdb, lockKey, lockValue, lockTTL)</span></span><br><span class="line"><span class="comment">//     if err != nil &#123;</span></span><br><span class="line"><span class="comment">//         c.JSON(http.StatusInternalServerError, gin.H&#123;&quot;error&quot;: &quot;Failed to obtain lock&quot;&#125;)</span></span><br><span class="line"><span class="comment">//         return</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     if !locked &#123;</span></span><br><span class="line"><span class="comment">//         c.JSON(http.StatusConflict, gin.H&#123;&quot;message&quot;: &quot;Resource is currently locked by another process&quot;&#125;)</span></span><br><span class="line"><span class="comment">//         return</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     defer func() &#123;</span></span><br><span class="line"><span class="comment">//         released, releaseErr := ReleaseLock(Rdb, lockKey, lockValue)</span></span><br><span class="line"><span class="comment">//         if releaseErr != nil &#123;</span></span><br><span class="line"><span class="comment">//             log.Printf(&quot;Failed to release lock for %s: %v&quot;, lockKey, releaseErr)</span></span><br><span class="line"><span class="comment">//         &#125; else if !released &#123;</span></span><br><span class="line"><span class="comment">//             log.Printf(&quot;Lock %s not released by current process (value mismatch)&quot;, lockKey)</span></span><br><span class="line"><span class="comment">//         &#125; else &#123;</span></span><br><span class="line"><span class="comment">//             log.Printf(&quot;Lock %s released successfully&quot;, lockKey)</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     // 执行需要加锁的业务逻辑</span></span><br><span class="line"><span class="comment">//     time.Sleep(5 * time.Second) // 模拟业务操作</span></span><br><span class="line"><span class="comment">//     c.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;Resource accessed successfully with lock&quot;&#125;)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure><h3 id="5-3-Pub-Sub（发布-订阅）"><a href="#5-3-Pub-Sub（发布-订阅）" class="headerlink" title="5.3 Pub&#x2F;Sub（发布&#x2F;订阅）"></a>5.3 Pub&#x2F;Sub（发布&#x2F;订阅）</h3><p>Redis 支持发布&#x2F;订阅模式，允许客户端订阅频道并接收其他客户端发布的消息，这在实现实时通知或事件驱动架构时非常有用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/go-redis/redis/v8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Rdb *redis.Client</span><br><span class="line"><span class="keyword">var</span> Ctx = context.Background()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initRedis</span><span class="params">()</span></span> &#123;</span><br><span class="line">Rdb = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr: <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">DB:   <span class="number">0</span>,</span><br><span class="line">&#125;)</span><br><span class="line">_, err := Rdb.Ping(Ctx).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Could not connect to Redis: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Connected to Redis for Pub/Sub&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SubscribeToChannel 订阅一个 Redis 频道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SubscribeToChannel</span><span class="params">(channel <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">pubsub := Rdb.Subscribe(Ctx, channel)</span><br><span class="line"><span class="keyword">defer</span> pubsub.Close() <span class="comment">// 确保订阅器在退出时关闭</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待订阅就绪</span></span><br><span class="line">_, err := pubsub.Receive(Ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Error receiving from pubsub: %v&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Subscribed to channel: %s&quot;</span>, channel)</span><br><span class="line"></span><br><span class="line">ch := pubsub.Channel() <span class="comment">// 获取消息通道</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> msg := <span class="keyword">range</span> ch &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Received message from channel &#x27;%s&#x27;: %s&quot;</span>, msg.Channel, msg.Payload)</span><br><span class="line"><span class="comment">// 在这里处理接收到的消息，例如推送到 WebSocket 客户端</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">initRedis()</span><br><span class="line"></span><br><span class="line">router := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动一个 goroutine 监听 Redis 消息</span></span><br><span class="line"><span class="keyword">go</span> SubscribeToChannel(<span class="string">&quot;my_chat_channel&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布消息的路由</span></span><br><span class="line">router.GET(<span class="string">&quot;/publish/:message&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">message := c.Param(<span class="string">&quot;message&quot;</span>)</span><br><span class="line">err := Rdb.Publish(Ctx, <span class="string">&quot;my_chat_channel&quot;</span>, message).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusInternalServerError, gin.H&#123;<span class="string">&quot;error&quot;</span>: fmt.Sprintf(<span class="string">&quot;Failed to publish message: %v&quot;</span>, err)&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: fmt.Sprintf(<span class="string">&quot;Message &#x27;%s&#x27; published to &#x27;my_chat_channel&#x27;&quot;</span>, message)&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Gin server running on :8080&quot;</span>)</span><br><span class="line">router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试 Pub&#x2F;Sub：</strong></p><ol><li>运行上面的 Gin 应用程序。</li><li>访问 <code>http://localhost:8080/publish/hello_world</code>。</li><li>查看应用程序的控制台输出，您会看到 <code>Received message from channel &#39;my_chat_channel&#39;: hello_world</code>，表明消息已成功发布并被订阅者接收。</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Backend </tag>
            
            <tag> Go </tag>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Viper 极简配置读取</title>
      <link href="/2025/06/03/viper/"/>
      <url>/2025/06/03/viper/</url>
      
        <content type="html"><![CDATA[<h1 id="Viper-极简配置读取指南"><a href="#Viper-极简配置读取指南" class="headerlink" title="Viper 极简配置读取指南"></a>Viper 极简配置读取指南</h1><p>Viper 是 Go 语言中一个非常方便的配置库。如果你想从文件中读取配置，并将其映射到 Go 结构体以便于类型安全的调用，Viper 能轻松搞定。</p><h2 id="1-安装-Viper"><a href="#1-安装-Viper" class="headerlink" title="1. 安装 Viper"></a>1. 安装 Viper</h2><p>首先，确保你的项目安装了 Viper</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/spf13/viper</span><br></pre></td></tr></table></figure><h2 id="2-准备配置文件"><a href="#2-准备配置文件" class="headerlink" title="2. 准备配置文件"></a>2. 准备配置文件</h2><p>Viper 支持多种配置文件格式，比如 YAML、JSON、TOML 等。我们以 <strong>YAML</strong> 格式为例，创建一个名为 <code>config.yaml</code> 的文件在你的项目根目录下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># config.yaml</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">MyWebApp</span></span><br><span class="line"><span class="attr">database:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">supersecret</span></span><br><span class="line">  <span class="comment"># 这个 timeout 字段在结构体中会用到，如果配置文件没有，会用结构体的默认值</span></span><br><span class="line">  <span class="attr">timeout_seconds:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="3-编写-Go-代码读取配置并绑定到结构体"><a href="#3-编写-Go-代码读取配置并绑定到结构体" class="headerlink" title="3. 编写 Go 代码读取配置并绑定到结构体"></a>3. 编写 Go 代码读取配置并绑定到结构体</h2><p>下面是一个简单的 Go 程序，演示了如何使用 Viper 读取 <code>config.yaml</code> 文件中的配置，并将其绑定到一个 Go 结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span> <span class="comment">// 用于输出错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Config 结构体映射整个配置文件。</span></span><br><span class="line"><span class="comment">// `mapstructure` 标签告诉 Viper 如何将配置键映射到结构体字段。</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">Server   ServerConfig   <span class="string">`mapstructure:&quot;server&quot;`</span></span><br><span class="line">Database DatabaseConfig <span class="string">`mapstructure:&quot;database&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServerConfig 映射 &#x27;server&#x27; 配置部分。</span></span><br><span class="line"><span class="keyword">type</span> ServerConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Port <span class="type">int</span>    <span class="string">`mapstructure:&quot;port&quot;`</span></span><br><span class="line">Name <span class="type">string</span> <span class="string">`mapstructure:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DatabaseConfig 映射 &#x27;database&#x27; 配置部分。</span></span><br><span class="line"><span class="keyword">type</span> DatabaseConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">Host           <span class="type">string</span> <span class="string">`mapstructure:&quot;host&quot;`</span></span><br><span class="line">User           <span class="type">string</span> <span class="string">`mapstructure:&quot;user&quot;`</span></span><br><span class="line">Password       <span class="type">string</span> <span class="string">`mapstructure:&quot;password&quot;`</span></span><br><span class="line">TimeoutSeconds <span class="type">int</span>    <span class="string">`mapstructure:&quot;timeout_seconds&quot;`</span> <span class="comment">// 即使配置文件没有，结构体也有默认值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 设置配置文件的名称 (不带扩展名)</span></span><br><span class="line">viper.SetConfigName(<span class="string">&quot;config&quot;</span>) <span class="comment">// 对应 config.yaml, config.json 等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置配置文件的类型 (可选，但推荐明确指定)</span></span><br><span class="line">viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>) <span class="comment">// 明确告诉 Viper 配置文件是 YAML 格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 添加查找配置文件的路径</span></span><br><span class="line"><span class="comment">// Viper 会按照添加的顺序查找，找到第一个就停止</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)        <span class="comment">// 在当前目录查找</span></span><br><span class="line">viper.AddConfigPath(<span class="string">&quot;./config&quot;</span>) <span class="comment">// 在当前目录下的 &#x27;config&#x27; 文件夹中查找 (如果你把 config.yaml 放在这里)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 读取配置文件</span></span><br><span class="line"><span class="keyword">if</span> err := viper.ReadInConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 如果配置文件没找到，这通常不是一个致命错误，</span></span><br><span class="line"><span class="comment">// 因为你可能想在生产环境通过环境变量或代码默认值提供配置。</span></span><br><span class="line"><span class="keyword">if</span> _, ok := err.(viper.ConfigFileNotFoundError); ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;No config file found, continuing with defaults or environment variables.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 其他类型的错误（如文件损坏），是致命错误</span></span><br><span class="line">log.Fatalf(<span class="string">&quot;Fatal error reading config file: %s \n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Config file &#x27;%s&#x27; loaded successfully!\n&quot;</span>, viper.ConfigFileUsed())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 绑定配置到结构体</span></span><br><span class="line"><span class="comment">// 定义一个 Config 结构体变量来接收配置</span></span><br><span class="line"><span class="keyword">var</span> appConfig Config</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值到结构体字段（可选，但推荐）</span></span><br><span class="line"><span class="comment">// 如果配置文件中没有 `timeout_seconds`，这里设置的 10 会生效。</span></span><br><span class="line">appConfig.Database.TimeoutSeconds = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := viper.Unmarshal(&amp;appConfig); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to unmarshal config into struct: %s \n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 通过结构体访问配置值 (推荐，类型安全，方便调用)</span></span><br><span class="line">fmt.Println(<span class="string">&quot;\n--- 通过结构体访问配置 ---&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Server Name: %s\n&quot;</span>, appConfig.Server.Name)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Server Port: %d\n&quot;</span>, appConfig.Server.Port)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Database Host: %s\n&quot;</span>, appConfig.Database.Host)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Database User: %s\n&quot;</span>, appConfig.Database.User)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Database Password: %s\n&quot;</span>, appConfig.Database.Password)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Database Timeout (seconds): %d\n&quot;</span>, appConfig.Database.TimeoutSeconds)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以直接通过 Viper 实例获取值（适用于少量或不方便映射到结构体的配置）</span></span><br><span class="line">fmt.Println(<span class="string">&quot;\n--- 直接通过 Viper.Get() 访问配置 ---&quot;</span>)</span><br><span class="line"><span class="comment">// 注意：当使用 Unmarshal 后，结构体是主要的访问方式。</span></span><br><span class="line"><span class="comment">// 但 Viper 实例仍然可以获取任何已加载的配置。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Server Port (from Viper.GetInt): %d\n&quot;</span>, viper.GetInt(<span class="string">&quot;server.port&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-运行你的程序"><a href="#4-运行你的程序" class="headerlink" title="4. 运行你的程序"></a>4. 运行你的程序</h2><ol><li><p>将上面的 Go 代码保存为 <code>main.go</code>。</p></li><li><p>确保 <code>config.yaml</code> 文件与 <code>main.go</code> 在同一目录下。</p></li><li><p>打开终端，进入该目录，然后运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure></li></ol><p>你将看到程序成功读取 <code>config.yaml</code>，并将其内容绑定到 <code>appConfig</code> 结构体，然后通过结构体字段访问配置值。</p><h3 id="结构体绑定小贴士："><a href="#结构体绑定小贴士：" class="headerlink" title="结构体绑定小贴士："></a>结构体绑定小贴士：</h3><ul><li><strong><code>mapstructure</code> 标签</strong>: <code>mapstructure:&quot;key_name&quot;</code> 告诉 Viper 如何将配置文件中的 <code>key_name</code> 字段映射到 Go 结构体的对应字段。这是必不可少的。</li><li><strong>嵌套结构体</strong>: 对于配置文件中的嵌套配置（如 <code>server</code> 和 <code>database</code>），Go 结构体也应使用嵌套结构体来匹配。</li><li><strong>默认值</strong>: 如果结构体字段是基本类型（如 <code>int</code>, <code>string</code>, <code>bool</code>），并且你在代码中给它赋了初始值（例如 <code>TimeoutSeconds int = 10</code>），那么在配置文件中没有这个键时，这个默认值就会被保留。如果配置文件有，则会被覆盖。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置读取 </tag>
            
            <tag> Viper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GORM 数据库操作</title>
      <link href="/2025/06/03/backend-gorm/"/>
      <url>/2025/06/03/backend-gorm/</url>
      
        <content type="html"><![CDATA[<h1 id="GORM-数据库操作速查手册"><a href="#GORM-数据库操作速查手册" class="headerlink" title="GORM 数据库操作速查手册"></a>GORM 数据库操作速查手册</h1><p>GORM 是 Go 语言中一个功能强大的 ORM (Object-Relational Mapping) 库。它提供了简洁的 API 来操作数据库，支持多种数据库（如 MySQL, PostgreSQL, SQLite, SQL Server 等）。</p><p>本文档将介绍 GORM 的常用操作：插入 (Create)、查询 (Retrieve)、更新 (Update) 和删除 (Delete)，并演示如何将查询结果赋值给 Go 语言的变量。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在开始之前，确保你已经安装了 GORM 和相应的数据库驱动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u gorm.io/gorm</span><br><span class="line">go get -u gorm.io/driver/sqlite <span class="comment"># 示例中使用 SQLite，你可以替换为其他数据库驱动</span></span><br></pre></td></tr></table></figure><h3 id="数据库连接与模型定义"><a href="#数据库连接与模型定义" class="headerlink" title="数据库连接与模型定义"></a>数据库连接与模型定义</h3><p>首先，我们需要建立数据库连接和定义一个数据模型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/driver/sqlite&quot;</span> <span class="comment">// 示例使用 SQLite</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// User 是一个 GORM 模型，映射到数据库中的 `users` 表</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// gorm.Model 包含了常用的字段: ID, CreatedAt, UpdatedAt, DeletedAt</span></span><br><span class="line"><span class="comment">// ID 是自增主键</span></span><br><span class="line">gorm.Model</span><br><span class="line">Name    <span class="type">string</span> <span class="string">`gorm:&quot;size:255;not null&quot;`</span> <span class="comment">// 姓名，非空</span></span><br><span class="line">Email   <span class="type">string</span> <span class="string">`gorm:&quot;unique;not null&quot;`</span>   <span class="comment">// 邮箱，唯一且非空</span></span><br><span class="line">Age     <span class="type">uint</span>   <span class="comment">// 年龄</span></span><br><span class="line">Balance <span class="type">float64</span> <span class="string">`gorm:&quot;default:0.0&quot;`</span> <span class="comment">// 余额，默认值为 0.0</span></span><br><span class="line"><span class="comment">// 还可以添加其他字段，例如：</span></span><br><span class="line"><span class="comment">// IsActive bool</span></span><br><span class="line"><span class="comment">// Address string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Global DB instance (全局 DB 实例，实际项目中通常通过依赖注入管理)</span></span><br><span class="line"><span class="keyword">var</span> DB *gorm.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"><span class="comment">// 连接到 SQLite 数据库 (test.db)</span></span><br><span class="line">DB, err = gorm.Open(sqlite.Open(<span class="string">&quot;test.db&quot;</span>), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;failed to connect database: &quot;</span> + err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动迁移模式，根据 User 结构体创建或更新数据库表</span></span><br><span class="line">err = DB.AutoMigrate(&amp;User&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;failed to auto migrate: &quot;</span> + err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Database connected and migrated successfully!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 这里可以调用各种操作函数进行演示</span></span><br><span class="line">fmt.Println(<span class="string">&quot;\n--- 开始 GORM 操作演示 ---&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入操作</span></span><br><span class="line">fmt.Println(<span class="string">&quot;\n--- 插入 (Create) ---&quot;</span>)</span><br><span class="line">user1 := createUser(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;alice@example.com&quot;</span>, <span class="number">30</span>)</span><br><span class="line">createUser(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;bob@example.com&quot;</span>, <span class="number">25</span>)</span><br><span class="line">createUsersBatch([]User&#123;</span><br><span class="line">&#123;Name: <span class="string">&quot;Charlie&quot;</span>, Email: <span class="string">&quot;charlie@example.com&quot;</span>, Age: <span class="number">35</span>&#125;,</span><br><span class="line">&#123;Name: <span class="string">&quot;David&quot;</span>, Email: <span class="string">&quot;david@example.com&quot;</span>, Age: <span class="number">40</span>&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询操作</span></span><br><span class="line">fmt.Println(<span class="string">&quot;\n--- 查询 (Retrieve) ---&quot;</span>)</span><br><span class="line">findUserByID(user1.ID)</span><br><span class="line">findUserByEmail(<span class="string">&quot;bob@example.com&quot;</span>)</span><br><span class="line">findAllUsers()</span><br><span class="line">findUsersByName(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">findUserWithConditions()</span><br><span class="line">findPaginatedUsers(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 第一页，每页2条</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新操作</span></span><br><span class="line">fmt.Println(<span class="string">&quot;\n--- 更新 (Update) ---&quot;</span>)</span><br><span class="line">updateUserByID(user1.ID, <span class="string">&quot;Alice Smith&quot;</span>, <span class="string">&quot;alice.smith@example.com&quot;</span>)</span><br><span class="line">updateUserColumnsByEmail(<span class="string">&quot;bob@example.com&quot;</span>, <span class="number">26</span>, <span class="number">100.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除操作</span></span><br><span class="line">fmt.Println(<span class="string">&quot;\n--- 删除 (Delete) ---&quot;</span>)</span><br><span class="line">deleteUserByID(user1.ID) <span class="comment">// 软删除</span></span><br><span class="line"><span class="comment">// hardDeleteUserByID(user1.ID) // 硬删除 (如果需要)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次查询所有用户，看软删除效果</span></span><br><span class="line">fmt.Println(<span class="string">&quot;\n--- 再次查询所有用户 (After Delete) ---&quot;</span>)</span><br><span class="line">findAllUsers()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-插入数据-Create"><a href="#1-插入数据-Create" class="headerlink" title="1. 插入数据 (Create)"></a>1. 插入数据 (Create)</h2><p>使用 <code>DB.Create()</code> 方法将新的记录插入到数据库中。</p><h3 id="1-1-插入单条记录"><a href="#1-1-插入单条记录" class="headerlink" title="1.1 插入单条记录"></a>1.1 插入单条记录</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createUser 插入单条用户记录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createUser</span><span class="params">(name, email <span class="type">string</span>, age <span class="type">uint</span>)</span></span> *User &#123;</span><br><span class="line">newUser := User&#123;</span><br><span class="line">Name:  name,</span><br><span class="line">Email: email,</span><br><span class="line">Age:   age,</span><br><span class="line">&#125;</span><br><span class="line">result := DB.Create(&amp;newUser) <span class="comment">// 传入结构体指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Error creating user %s: %v\n&quot;</span>, name, result.Error)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Successfully created user: %s (ID: %d), Rows Affected: %d\n&quot;</span>, newUser.Name, newUser.ID, result.RowsAffected)</span><br><span class="line"><span class="keyword">return</span> &amp;newUser <span class="comment">// GORM 会将新记录的 ID 填充回结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user1 := createUser(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;alice@example.com&quot;</span>, <span class="number">30</span>)</span><br><span class="line"><span class="comment">// 此时 user1.ID 会被 GORM 填充为新插入记录的自增 ID</span></span><br></pre></td></tr></table></figure><h3 id="1-2-批量插入记录"><a href="#1-2-批量插入记录" class="headerlink" title="1.2 批量插入记录"></a>1.2 批量插入记录</h3><p>传递一个结构体切片给 <code>DB.Create()</code> 即可实现批量插入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createUsersBatch 批量插入用户记录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createUsersBatch</span><span class="params">(users []User)</span></span> &#123;</span><br><span class="line">result := DB.Create(&amp;users) <span class="comment">// 传入结构体切片指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Error creating users batch: %v\n&quot;</span>, result.Error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Successfully created %d users in batch.\n&quot;</span>, result.RowsAffected)</span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> users &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;  - %s (ID: %d)\n&quot;</span>, user.Name, user.ID)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">createUsersBatch([]User&#123;</span><br><span class="line">&#123;Name: <span class="string">&quot;Charlie&quot;</span>, Email: <span class="string">&quot;charlie@example.com&quot;</span>, Age: <span class="number">35</span>&#125;,</span><br><span class="line">&#123;Name: <span class="string">&quot;David&quot;</span>, Email: <span class="string">&quot;david@example.com&quot;</span>, Age: <span class="number">40</span>&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-查询数据-Retrieve"><a href="#2-查询数据-Retrieve" class="headerlink" title="2. 查询数据 (Retrieve)"></a>2. 查询数据 (Retrieve)</h2><p>GORM 提供了多种查询方法，可以灵活地检索数据。查询结果会赋值给 Go 语言的变量。</p><h3 id="2-1-根据主键查询-First-Find"><a href="#2-1-根据主键查询-First-Find" class="headerlink" title="2.1 根据主键查询 (First &#x2F; Find)"></a>2.1 根据主键查询 (First &#x2F; Find)</h3><ul><li><code>First(&amp;dest, primaryKey)</code>: 查找主键匹配的第一个记录。如果没有找到记录，<code>result.Error</code> 会是 <code>gorm.ErrRecordNotFound</code>。</li><li><code>Find(&amp;dest, primaryKey)</code>: 查找主键匹配的所有记录。如果找到多个，只会赋值给切片。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// findUserByID 根据 ID 查询用户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUserByID</span><span class="params">(id <span class="type">uint</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line"><span class="comment">// First 会根据主键查找，如果找不到会返回 gorm.ErrRecordNotFound</span></span><br><span class="line">result := DB.First(&amp;user, id) <span class="comment">// 传入结构体指针和主键值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> result.Error == gorm.ErrRecordNotFound &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;User with ID %d not found.\n&quot;</span>, id)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Error finding user by ID %d: %v\n&quot;</span>, id, result.Error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Found User by ID %d: Name=%s, Email=%s, Age=%d\n&quot;</span>, user.ID, user.Name, user.Email, user.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findUserByID(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="2-2-根据条件查询-Where"><a href="#2-2-根据条件查询-Where" class="headerlink" title="2.2 根据条件查询 (Where)"></a>2.2 根据条件查询 (Where)</h3><p>使用 <code>Where()</code> 方法添加查询条件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// findUserByEmail 根据邮箱查询用户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUserByEmail</span><span class="params">(email <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line"><span class="comment">// Where 方法用于构建查询条件</span></span><br><span class="line">result := DB.Where(<span class="string">&quot;email = ?&quot;</span>, email).First(&amp;user) <span class="comment">// 使用占位符防止 SQL 注入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> result.Error == gorm.ErrRecordNotFound &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;User with email %s not found.\n&quot;</span>, email)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Error finding user by email %s: %v\n&quot;</span>, email, result.Error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Found User by Email %s: Name=%s, Age=%d\n&quot;</span>, user.Email, user.Name, user.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// findUsersByName 根据姓名模糊查询所有匹配的用户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUsersByName</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> users []User <span class="comment">// 声明一个结构体切片来存储多条记录</span></span><br><span class="line"><span class="comment">// 使用 LIKE 进行模糊匹配</span></span><br><span class="line">result := DB.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%&quot;</span>+name+<span class="string">&quot;%&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Error finding users by name %s: %v\n&quot;</span>, name, result.Error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(users) == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;No users found with name containing &#x27;%s&#x27;.\n&quot;</span>, name)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Found %d users with name containing &#x27;%s&#x27;:\n&quot;</span>, <span class="built_in">len</span>(users), name)</span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> users &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;  - ID: %d, Name: %s, Email: %s\n&quot;</span>, user.ID, user.Name, user.Email)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// findUserWithConditions 复杂条件查询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUserWithConditions</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line"><span class="comment">// 链式调用多个 Where 条件</span></span><br><span class="line">result := DB.Where(<span class="string">&quot;age &gt; ?&quot;</span>, <span class="number">20</span>).Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%lice%&quot;</span>).First(&amp;user)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> result.Error == gorm.ErrRecordNotFound &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;No user found with age &gt; 20 and name like &#x27;%lice%&#x27;.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Error finding user with conditions: %v\n&quot;</span>, result.Error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Found User with conditions: ID=%d, Name=%s, Age=%d\n&quot;</span>, user.ID, user.Name, user.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">findUserByEmail(<span class="string">&quot;bob@example.com&quot;</span>)</span><br><span class="line">findUsersByName(<span class="string">&quot;li&quot;</span>) <span class="comment">// 查找名字中包含 &quot;li&quot; 的用户</span></span><br></pre></td></tr></table></figure><h3 id="2-3-查询所有记录-Find"><a href="#2-3-查询所有记录-Find" class="headerlink" title="2.3 查询所有记录 (Find)"></a>2.3 查询所有记录 (Find)</h3><p>不带 <code>Where()</code> 条件的 <code>Find()</code> 方法会查询表中的所有记录。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// findAllUsers 查询所有用户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findAllUsers</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> users []User <span class="comment">// 声明一个结构体切片</span></span><br><span class="line">result := DB.Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Error finding all users: %v\n&quot;</span>, result.Error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(users) == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;No users found in the database.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Found %d users:\n&quot;</span>, <span class="built_in">len</span>(users))</span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> users &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;  - ID: %d, Name: %s, Email: %s, Age: %d, CreatedAt: %s\n&quot;</span>,</span><br><span class="line">user.ID, user.Name, user.Email, user.Age, user.CreatedAt.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findAllUsers()</span><br></pre></td></tr></table></figure><h3 id="2-4-排序、限制和偏移-Order-Limit-Offset"><a href="#2-4-排序、限制和偏移-Order-Limit-Offset" class="headerlink" title="2.4 排序、限制和偏移 (Order, Limit, Offset)"></a>2.4 排序、限制和偏移 (Order, Limit, Offset)</h3><p>用于分页和排序查询结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// findPaginatedUsers 分页查询用户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findPaginatedUsers</span><span class="params">(page, pageSize <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> users []User</span><br><span class="line">offset := (page - <span class="number">1</span>) * pageSize <span class="comment">// 计算偏移量</span></span><br><span class="line"></span><br><span class="line">result := DB.Offset(offset).Limit(pageSize).Order(<span class="string">&quot;created_at desc&quot;</span>).Find(&amp;users)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Error finding paginated users (Page %d, Size %d): %v\n&quot;</span>, page, pageSize, result.Error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(users) == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;No users found on page %d (size %d).\n&quot;</span>, page, pageSize)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Found %d users on Page %d (Size %d):\n&quot;</span>, <span class="built_in">len</span>(users), page, pageSize)</span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> users &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;  - ID: %d, Name: %s, CreatedAt: %s\n&quot;</span>, user.ID, user.Name, user.CreatedAt.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findPaginatedUsers(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 查询第一页，每页2条</span></span><br></pre></td></tr></table></figure><h2 id="3-更新数据-Update"><a href="#3-更新数据-Update" class="headerlink" title="3. 更新数据 (Update)"></a>3. 更新数据 (Update)</h2><p>GORM 提供了多种更新数据的方法。</p><h3 id="3-1-更新单个字段-Update"><a href="#3-1-更新单个字段-Update" class="headerlink" title="3.1 更新单个字段 (Update)"></a>3.1 更新单个字段 (Update)</h3><p><code>Update()</code> 方法用于更新模型的单个字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// updateUserByID 根据 ID 更新用户姓名和邮箱</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateUserByID</span><span class="params">(id <span class="type">uint</span>, newName, newEmail <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line"><span class="comment">// 首先找到记录</span></span><br><span class="line">result := DB.First(&amp;user, id)</span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Error finding user ID %d for update: %v\n&quot;</span>, id, result.Error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新单个字段</span></span><br><span class="line"><span class="comment">// DB.Model(&amp;user).Update(&quot;name&quot;, newName) // 更新单个字段</span></span><br><span class="line"><span class="comment">// DB.Model(&amp;user).Update(&quot;email&quot;, newEmail)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新多个字段 (使用 map 或结构体)</span></span><br><span class="line">result = DB.Model(&amp;user).Updates(User&#123;Name: newName, Email: newEmail&#125;) <span class="comment">// 使用结构体更新</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// result = DB.Model(&amp;user).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: newName, &quot;email&quot;: newEmail&#125;) // 使用 map 更新</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Error updating user ID %d: %v\n&quot;</span>, id, result.Error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Successfully updated user ID %d to Name: %s, Email: %s, Rows Affected: %d\n&quot;</span>, id, newName, newEmail, result.RowsAffected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updateUserByID(<span class="number">1</span>, <span class="string">&quot;Alice Smith&quot;</span>, <span class="string">&quot;alice.smith@example.com&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-2-更新多个字段-Updates"><a href="#3-2-更新多个字段-Updates" class="headerlink" title="3.2 更新多个字段 (Updates)"></a>3.2 更新多个字段 (Updates)</h3><p><code>Updates()</code> 方法用于更新模型的多个字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// updateUserColumnsByEmail 根据邮箱更新用户年龄和余额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateUserColumnsByEmail</span><span class="params">(email <span class="type">string</span>, newAge <span class="type">uint</span>, newBalance <span class="type">float64</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 使用 Where 找到记录，然后用 Updates 更新</span></span><br><span class="line">result := DB.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;email = ?&quot;</span>, email).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">&quot;age&quot;</span>:     newAge,</span><br><span class="line"><span class="string">&quot;balance&quot;</span>: newBalance,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Error updating user by email %s: %v\n&quot;</span>, email, result.Error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> result.RowsAffected == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;No user found with email %s to update.\n&quot;</span>, email)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Successfully updated user with email %s, Rows Affected: %d\n&quot;</span>, email, result.RowsAffected)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updateUserColumnsByEmail(<span class="string">&quot;bob@example.com&quot;</span>, <span class="number">26</span>, <span class="number">100.5</span>)</span><br></pre></td></tr></table></figure><h3 id="3-3-计数器更新-Inc-Dec"><a href="#3-3-计数器更新-Inc-Dec" class="headerlink" title="3.3 计数器更新 (Inc &#x2F; Dec)"></a>3.3 计数器更新 (Inc &#x2F; Dec)</h3><p>用于原子性地增加或减少字段值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// incrementUserAge 增加用户年龄</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementUserAge</span><span class="params">(id <span class="type">uint</span>, delta <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">result := DB.First(&amp;user, id)</span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Error finding user ID %d for age increment: %v\n&quot;</span>, id, result.Error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = DB.Model(&amp;user).Update(<span class="string">&quot;age&quot;</span>, gorm.Expr(<span class="string">&quot;age + ?&quot;</span>, delta))</span><br><span class="line"><span class="comment">// 或者使用 Inc/Dec 方法 (GORM v1.20.0+):</span></span><br><span class="line"><span class="comment">// result = DB.Model(&amp;user).Inc(&quot;age&quot;, delta)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Error incrementing age for user ID %d: %v\n&quot;</span>, id, result.Error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Successfully incremented age for user ID %d, Rows Affected: %d\n&quot;</span>, id, result.RowsAffected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-删除数据-Delete"><a href="#4-删除数据-Delete" class="headerlink" title="4. 删除数据 (Delete)"></a>4. 删除数据 (Delete)</h2><p>GORM 支持软删除和硬删除。</p><h3 id="4-1-软删除-Soft-Delete"><a href="#4-1-软删除-Soft-Delete" class="headerlink" title="4.1 软删除 (Soft Delete)"></a>4.1 软删除 (Soft Delete)</h3><p>如果你的模型嵌入了 <code>gorm.Model</code>（或包含 <code>DeletedAt gorm.DeletedAt</code> 字段），GORM 默认会进行软删除。它不会真正删除记录，而是将 <code>DeletedAt</code> 字段设置为当前时间。</p><p>软删除的记录在常规查询中不会被检索到，除非使用 <code>Unscoped()</code> 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deleteUserByID 软删除用户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteUserByID</span><span class="params">(id <span class="type">uint</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line"><span class="comment">// 使用 Delete 方法进行软删除</span></span><br><span class="line">result := DB.Delete(&amp;user, id) <span class="comment">// 传入结构体指针和主键值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Error soft deleting user ID %d: %v\n&quot;</span>, id, result.Error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Successfully soft deleted user ID %d, Rows Affected: %d\n&quot;</span>, id, result.RowsAffected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// findDeletedUserByID 查找被软删除的用户 (需要 Unscoped)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDeletedUserByID</span><span class="params">(id <span class="type">uint</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line"><span class="comment">// 使用 Unscoped() 方法可以查询被软删除的记录</span></span><br><span class="line">result := DB.Unscoped().First(&amp;user, id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> result.Error == gorm.ErrRecordNotFound &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;User with ID %d (including deleted) not found.\n&quot;</span>, id)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Error finding deleted user by ID %d: %v\n&quot;</span>, id, result.Error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Found Deleted User by ID %d: Name=%s, DeletedAt=%s\n&quot;</span>, user.ID, user.Name, user.DeletedAt.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deleteUserByID(<span class="number">1</span>) <span class="comment">// 软删除 ID 为 1 的用户</span></span><br><span class="line">findUserByID(<span class="number">1</span>)   <span class="comment">// 此时应该找不到 ID 为 1 的用户</span></span><br><span class="line">findDeletedUserByID(<span class="number">1</span>) <span class="comment">// 可以找到被软删除的用户</span></span><br></pre></td></tr></table></figure><h3 id="4-2-硬删除-Permanent-Delete"><a href="#4-2-硬删除-Permanent-Delete" class="headerlink" title="4.2 硬删除 (Permanent Delete)"></a>4.2 硬删除 (Permanent Delete)</h3><p>如果你想彻底从数据库中删除记录，可以使用 <code>Unscoped().Delete()</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hardDeleteUserByID 硬删除用户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hardDeleteUserByID</span><span class="params">(id <span class="type">uint</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line"><span class="comment">// 使用 Unscoped().Delete() 进行硬删除</span></span><br><span class="line">result := DB.Unscoped().Delete(&amp;user, id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Error hard deleting user ID %d: %v\n&quot;</span>, id, result.Error)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Successfully hard deleted user ID %d, Rows Affected: %d\n&quot;</span>, id, result.RowsAffected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hardDeleteUserByID(1) // 硬删除 ID 为 1 的用户</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文档涵盖了 GORM 中最常用的数据库操作方法。GORM 还有许多高级功能，例如：</p><ul><li><strong>关联 (Associations)</strong>：一对一、一对多、多对多关系。</li><li><strong>事务 (Transactions)</strong>：确保一系列数据库操作的原子性。</li><li><strong>预加载 (Preloading)</strong>：一次性加载关联数据以避免 N+1 查询问题。</li><li><strong>Hook (钩子)</strong>：在创建、更新、删除等操作前后执行自定义逻辑。</li><li><strong>原生 SQL (Raw SQL)</strong>：当 ORM 无法满足需求时，直接执行 SQL 语句。</li></ul><p>查阅 <a href="https://gorm.io/zh_CN/docs/index.html">GORM 官方文档</a> 以获取更多详细信息和高级用法。 </p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Backend </tag>
            
            <tag> GORM </tag>
            
            <tag> 项目 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin Web Framework 使用</title>
      <link href="/2025/06/03/backend-gin/"/>
      <url>/2025/06/03/backend-gin/</url>
      
        <content type="html"><![CDATA[<h1 id="Gin-Web-Framework"><a href="#Gin-Web-Framework" class="headerlink" title="Gin Web Framework"></a>Gin Web Framework</h1><p>Gin 是一个用 Go 语言编写的 HTTP Web 框架，它以其高性能和低内存占用而闻名。Gin 具有类似 Martini 的 API，但性能更好，这得益于其高度优化的 HTTP 路由器。</p><p>本文档将介绍 Gin 的核心概念和常用功能，包括路由、参数绑定、JSON 响应、中间件等。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先，你需要安装 Gin 框架：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><h3 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h3><p>一个基本的 Gin 应用通常包含以下部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span> <span class="comment">// 用于 HTTP 状态码</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span>      <span class="comment">// 用于打印输出</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 创建一个 Gin 路由器实例</span></span><br><span class="line"><span class="comment">// gin.Default() 包含了 Logger 和 Recovery 中间件</span></span><br><span class="line">router := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义路由和处理函数 (Handlers)</span></span><br><span class="line">router.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// c.JSON() 方法用于返回 JSON 响应</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello, Gin!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.String(http.StatusOK, <span class="string">&quot;pong&quot;</span>) <span class="comment">// c.String() 用于返回纯文本响应</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 运行服务器</span></span><br><span class="line"><span class="comment">// 默认在 8080 端口启动</span></span><br><span class="line"><span class="keyword">if</span> err := router.Run(<span class="string">&quot;:8080&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Server failed to start: %v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 <code>go run your_app.go</code> 后，访问 <code>http://localhost:8080</code> 或 <code>http://localhost:8080/ping</code> 即可看到效果。</p><h2 id="1-路由-Routing"><a href="#1-路由-Routing" class="headerlink" title="1. 路由 (Routing)"></a>1. 路由 (Routing)</h2><p>Gin 提供了简洁的 API 来定义各种 HTTP 请求方法的路由。</p><h3 id="1-1-基本路由"><a href="#1-1-基本路由" class="headerlink" title="1.1 基本路由"></a>1.1 基本路由</h3><p>你可以使用 <code>router.GET()</code>, <code>router.POST()</code>, <code>router.PUT()</code>, <code>router.DELETE()</code>, <code>router.PATCH()</code>, <code>router.HEAD()</code>, <code>router.OPTIONS()</code> 等方法来处理不同的 HTTP 请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET 请求</span></span><br><span class="line">router.GET(<span class="string">&quot;/users&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;data&quot;</span>: <span class="string">&quot;Get all users&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST 请求</span></span><br><span class="line">router.POST(<span class="string">&quot;/users&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusCreated, gin.H&#123;<span class="string">&quot;data&quot;</span>: <span class="string">&quot;Create a new user&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// PUT 请求</span></span><br><span class="line">router.PUT(<span class="string">&quot;/users/:id&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    id := c.Param(<span class="string">&quot;id&quot;</span>) <span class="comment">// 获取路径参数</span></span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;data&quot;</span>: <span class="string">&quot;Update user &quot;</span> + id&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// DELETE 请求</span></span><br><span class="line">router.DELETE(<span class="string">&quot;/users/:id&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    id := c.Param(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;data&quot;</span>: <span class="string">&quot;Delete user &quot;</span> + id&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="1-2-路径参数-Path-Parameters"><a href="#1-2-路径参数-Path-Parameters" class="headerlink" title="1.2 路径参数 (Path Parameters)"></a>1.2 路径参数 (Path Parameters)</h3><p>使用冒号 <code>:</code> 定义路径参数。你可以通过 <code>c.Param(&quot;参数名&quot;)</code> 来获取。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配 /users/123, /users/abc 等</span></span><br><span class="line">router.GET(<span class="string">&quot;/users/:id&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">id := c.Param(<span class="string">&quot;id&quot;</span>) <span class="comment">// 获取路径参数 &quot;id&quot;</span></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;user_id&quot;</span>: id&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多参数匹配</span></span><br><span class="line">router.GET(<span class="string">&quot;/users/:id/:action&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">id := c.Param(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">action := c.Param(<span class="string">&quot;action&quot;</span>)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;user_id&quot;</span>: id, <span class="string">&quot;action&quot;</span>: action&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="1-3-查询字符串参数-Query-String-Parameters"><a href="#1-3-查询字符串参数-Query-String-Parameters" class="headerlink" title="1.3 查询字符串参数 (Query String Parameters)"></a>1.3 查询字符串参数 (Query String Parameters)</h3><p>通过 <code>c.Query(&quot;参数名&quot;)</code> 或 <code>c.DefaultQuery(&quot;参数名&quot;, &quot;默认值&quot;)</code> 获取 URL 中的查询参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问 /search?name=test&amp;age=18</span></span><br><span class="line">router.GET(<span class="string">&quot;/search&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">name := c.Query(<span class="string">&quot;name&quot;</span>)              <span class="comment">// 获取 &quot;name&quot; 参数，如果不存在则为空字符串</span></span><br><span class="line">age := c.DefaultQuery(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;0&quot;</span>) <span class="comment">// 获取 &quot;age&quot; 参数，如果不存在则为 &quot;0&quot;</span></span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: name,</span><br><span class="line"><span class="string">&quot;age&quot;</span>:  age,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="1-4-路由组-Route-Groups"><a href="#1-4-路由组-Route-Groups" class="headerlink" title="1.4 路由组 (Route Groups)"></a>1.4 路由组 (Route Groups)</h3><p>使用 <code>router.Group()</code> 可以组织路由，并为路由组应用相同的中间件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 /api/v1 路由组</span></span><br><span class="line">v1 := router.Group(<span class="string">&quot;/api/v1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">v1.GET(<span class="string">&quot;/posts&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Get all v1 posts&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">v1.POST(<span class="string">&quot;/posts&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(http.StatusCreated, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Create a v1 post&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 /api/v2 路由组</span></span><br><span class="line">v2 := router.Group(<span class="string">&quot;/api/v2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">v2.GET(<span class="string">&quot;/users&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Get all v2 users&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-参数绑定-Binding"><a href="#2-参数绑定-Binding" class="headerlink" title="2. 参数绑定 (Binding)"></a>2. 参数绑定 (Binding)</h2><p>Gin 提供了强大的参数绑定功能，可以将请求数据（JSON, Form, Query 等）自动绑定到 Go 结构体。</p><h3 id="2-1-JSON-请求体绑定"><a href="#2-1-JSON-请求体绑定" class="headerlink" title="2.1 JSON 请求体绑定"></a>2.1 JSON 请求体绑定</h3><p>使用 <code>c.BindJSON(&amp;struct&#123;&#125;)</code> 或 <code>c.ShouldBindJSON(&amp;struct&#123;&#125;)</code>。<code>ShouldBindJSON</code> 在绑定失败时会返回错误，你可以根据错误进行处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LoginForm <span class="keyword">struct</span> &#123;</span><br><span class="line">User     <span class="type">string</span> <span class="string">`json:&quot;user&quot; binding:&quot;required&quot;`</span>     <span class="comment">// `required` 标签表示该字段是必需的</span></span><br><span class="line">Password <span class="type">string</span> <span class="string">`json:&quot;password&quot; binding:&quot;required&quot;`</span> <span class="comment">// `json` 标签用于 JSON 字段名映射</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> form LoginForm</span><br><span class="line"><span class="comment">// Try to bind JSON to form</span></span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBindJSON(&amp;form); err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> form.User == <span class="string">&quot;admin&quot;</span> &amp;&amp; form.Password == <span class="string">&quot;password&quot;</span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;login success&quot;</span>&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.JSON(http.StatusUnauthorized, gin.H&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;unauthorized&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>示例 JSON 请求体:</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-Form-x-www-form-urlencoded-或-multipart-form-data-绑定"><a href="#2-2-Form-x-www-form-urlencoded-或-multipart-form-data-绑定" class="headerlink" title="2.2 Form (x-www-form-urlencoded 或 multipart&#x2F;form-data) 绑定"></a>2.2 Form (x-www-form-urlencoded 或 multipart&#x2F;form-data) 绑定</h3><p>使用 <code>c.Bind(&amp;struct&#123;&#125;)</code> 或 <code>c.ShouldBind(&amp;struct&#123;&#125;)</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserForm <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="type">string</span> <span class="string">`form:&quot;name&quot; binding:&quot;required&quot;`</span></span><br><span class="line">Email <span class="type">string</span> <span class="string">`form:&quot;email&quot; binding:&quot;required,email&quot;`</span> <span class="comment">// 示例：email 字段需要是有效的邮箱格式</span></span><br><span class="line">Age   <span class="type">int</span>    <span class="string">`form:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.POST(<span class="string">&quot;/submit_user&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> userForm UserForm</span><br><span class="line"><span class="keyword">if</span> err := c.ShouldBind(&amp;userForm); err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;User received&quot;</span>, <span class="string">&quot;user&quot;</span>: userForm&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>示例 Form 请求体 (Content-Type: application&#x2F;x-www-form-urlencoded):</strong> <code>name=John+Doe&amp;email=john%40example.com&amp;age=30</code></p><h3 id="2-3-查询参数绑定"><a href="#2-3-查询参数绑定" class="headerlink" title="2.3 查询参数绑定"></a>2.3 查询参数绑定</h3><p>可以将查询参数绑定到结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PersonQuery <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span> <span class="string">`form:&quot;name&quot;`</span></span><br><span class="line">City <span class="type">string</span> <span class="string">`form:&quot;city&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.GET(<span class="string">&quot;/person&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> person PersonQuery</span><br><span class="line"><span class="keyword">if</span> c.ShouldBindQuery(&amp;person) == <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;query_name&quot;</span>: person.Name, <span class="string">&quot;query_city&quot;</span>: person.City&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;Invalid query parameters&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>示例 URL:</strong> <code>/person?name=Alice&amp;city=NewYork</code></p><h2 id="3-响应-Responses"><a href="#3-响应-Responses" class="headerlink" title="3. 响应 (Responses)"></a>3. 响应 (Responses)</h2><p>Gin 提供了多种发送响应的方法。</p><h3 id="3-1-JSON-响应"><a href="#3-1-JSON-响应" class="headerlink" title="3.1 JSON 响应"></a>3.1 JSON 响应</h3><p>这是最常用的响应类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.JSON(http.StatusOK, gin.H&#123;&quot;foo&quot;: &quot;bar&quot;&#125;) // 简单的 map</span></span><br><span class="line"><span class="comment">// c.JSON(http.StatusOK, someStructInstance)    // Go 结构体</span></span><br><span class="line"><span class="comment">// c.JSON(http.StatusOK, []SomeStruct&#123;&#125;)        // 结构体切片</span></span><br></pre></td></tr></table></figure><h3 id="3-2-纯文本响应"><a href="#3-2-纯文本响应" class="headerlink" title="3.2 纯文本响应"></a>3.2 纯文本响应</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.String(http.StatusOK, <span class="string">&quot;Hello, %s&quot;</span>, <span class="string">&quot;World&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-3-HTML-响应"><a href="#3-3-HTML-响应" class="headerlink" title="3.3 HTML 响应"></a>3.3 HTML 响应</h3><p>你需要加载 HTML 模板。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载模板文件</span></span><br><span class="line">router.LoadHTMLGlob(<span class="string">&quot;templates/*&quot;</span>) <span class="comment">// 假设 HTML 文件在 templates 目录下</span></span><br><span class="line"></span><br><span class="line">router.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">&quot;index.html&quot;</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;title&quot;</span>: <span class="string">&quot;Gin HTML Page&quot;</span>,</span><br><span class="line"><span class="string">&quot;data&quot;</span>:  <span class="string">&quot;Welcome to Gin!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><code>templates/index.html</code> 示例:</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123; .title &#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; .data &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-4-重定向-Redirect"><a href="#3-4-重定向-Redirect" class="headerlink" title="3.4 重定向 (Redirect)"></a>3.4 重定向 (Redirect)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.GET(<span class="string">&quot;/redirect&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.Redirect(http.StatusMovedPermanently, <span class="string">&quot;http://www.google.com&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-中间件-Middlewares"><a href="#4-中间件-Middlewares" class="headerlink" title="4. 中间件 (Middlewares)"></a>4. 中间件 (Middlewares)</h2><p>中间件是在请求被处理之前或之后执行的代码。Gin 支持全局中间件、路由组中间件和单个路由中间件。</p><h3 id="4-1-全局中间件"><a href="#4-1-全局中间件" class="headerlink" title="4.1 全局中间件"></a>4.1 全局中间件</h3><p>应用于所有路由。<code>gin.Default()</code> 已经默认包含了 <code>Logger</code> 和 <code>Recovery</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动添加中间件 (如果不用 gin.Default())</span></span><br><span class="line"><span class="comment">// router := gin.New()</span></span><br><span class="line"><span class="comment">// router.Use(gin.Logger())   // 请求日志</span></span><br><span class="line"><span class="comment">// router.Use(gin.Recovery()) // 崩溃恢复</span></span><br></pre></td></tr></table></figure><h3 id="4-2-路由组中间件"><a href="#4-2-路由组中间件" class="headerlink" title="4.2 路由组中间件"></a>4.2 路由组中间件</h3><p>应用于路由组内的所有路由。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthMiddleware</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">token := c.GetHeader(<span class="string">&quot;Authorization&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> token != <span class="string">&quot;valid-token&quot;</span> &#123; <span class="comment">// 简单模拟认证</span></span><br><span class="line">c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Unauthorized&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">c.Next() <span class="comment">// 调用链中的下一个中间件或处理函数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">authorized := router.Group(<span class="string">&quot;/admin&quot;</span>, AuthMiddleware()) <span class="comment">// 为 /admin 组应用 AuthMiddleware</span></span><br><span class="line">&#123;</span><br><span class="line">authorized.GET(<span class="string">&quot;/dashboard&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Welcome to admin dashboard&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-单个路由中间件"><a href="#4-3-单个路由中间件" class="headerlink" title="4.3 单个路由中间件"></a>4.3 单个路由中间件</h3><p>只应用于特定的路由。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.GET(<span class="string">&quot;/ping_auth&quot;</span>, AuthMiddleware(), <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong with auth&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4-4-中间件中的上下文数据传递"><a href="#4-4-中间件中的上下文数据传递" class="headerlink" title="4.4 中间件中的上下文数据传递"></a>4.4 中间件中的上下文数据传递</h3><p>你可以使用 <code>c.Set()</code> 和 <code>c.Get()</code> 在中间件之间或中间件和处理函数之间传递数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserInfoMiddleware</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 假设从 JWT 或其他地方解析出用户信息</span></span><br><span class="line">userID := <span class="string">&quot;user123&quot;</span></span><br><span class="line">c.Set(<span class="string">&quot;userID&quot;</span>, userID) <span class="comment">// 设置上下文变量</span></span><br><span class="line">c.Next()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.GET(<span class="string">&quot;/profile&quot;</span>, UserInfoMiddleware(), <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">userID, exists := c.Get(<span class="string">&quot;userID&quot;</span>) <span class="comment">// 获取上下文变量</span></span><br><span class="line"><span class="keyword">if</span> !exists &#123;</span><br><span class="line">c.JSON(http.StatusInternalServerError, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;User ID not found in context&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: fmt.Sprintf(<span class="string">&quot;Welcome, User %s&quot;</span>, userID)&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="5-错误处理-Error-Handling"><a href="#5-错误处理-Error-Handling" class="headerlink" title="5. 错误处理 (Error Handling)"></a>5. 错误处理 (Error Handling)</h2><p>Gin 允许你收集和处理请求过程中发生的错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">router.GET(<span class="string">&quot;/error_example&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 记录一个错误</span></span><br><span class="line">c.Error(fmt.Errorf(<span class="string">&quot;this is a custom error&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以在错误后中止请求链</span></span><br><span class="line"><span class="comment">// c.AbortWithError(http.StatusInternalServerError, fmt.Errorf(&quot;something bad happened&quot;))</span></span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Check server logs for errors&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Gin 的 <code>Logger</code> 中间件会自动打印 <code>c.Errors</code> 中的错误。你也可以创建自定义的错误处理中间件来集中管理错误响应。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Gin 是一个快速、灵活且易于使用的 Go Web 框架。掌握以上基础知识，你就可以开始构建功能强大的 Web 应用了。</p><p>Gin 还有许多高级特性，例如：</p><ul><li><strong>文件上传</strong></li><li><strong>静态文件服务</strong></li><li><strong>HTML 模板渲染</strong></li><li><strong>Cookie 和 Session 管理</strong></li><li><strong>Multipart 表单处理</strong></li><li><strong>自定义验证器</strong></li></ul><p>查阅 <a href="https://gin-gonic.com/zh-cn/docs/">Gin 官方文档</a> 以获取更多详细信息和高级用法。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Backend </tag>
            
            <tag> Go </tag>
            
            <tag> Gin </tag>
            
            <tag> Web Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客搭建指南</title>
      <link href="/2025/06/02/WebBlog/"/>
      <url>/2025/06/02/WebBlog/</url>
      
        <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="官网资料"><a href="#官网资料" class="headerlink" title="官网资料"></a>官网资料</h2><p>hexo官网配置参考<a href="https://hexo.io/zh-cn/docs/commands">hexo 指令</a></p><p>主题 anzhiyu 配置参考<a href="https://docs.anheyu.com/page/front-matter.html">安知鱼主题</a></p><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>打开本地调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// cmd</span><br><span class="line">hexo clean</span><br><span class="line">hexo server</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">hexo cl &amp;&amp; hexo s</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">// vscode</span><br><span class="line">hexo cl; hexo s</span><br></pre></td></tr></table></figure><p>推送更改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// cmd</span><br><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line">// vscode</span><br><span class="line">hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">hexo cl; hexo g; hexo d</span><br></pre></td></tr></table></figure><p>设置标签页和分类页</p><h1 id="基础流程"><a href="#基础流程" class="headerlink" title="基础流程"></a>基础流程</h1><h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><ol><li><p>给出原始md文档，移入<code>./source/_posts</code>中</p></li><li><p>在md开头加入yaml配置信息，字段参考<a href="https://docs.anheyu.com/page/front-matter.html">front-matter</a></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 我的第一篇 Hexo 文章</span><br><span class="line">date: 2025-06-02 20:30:00 # 不填默认设置生成静态文件的时间</span><br><span class="line">location: 成都 # 不填默认成都</span><br><span class="line">tags: # 标签，可以有多个</span><br><span class="line"><span class="bullet">  -</span> Hexo</span><br><span class="line"><span class="bullet">  -</span> 博客</span><br><span class="line"><span class="bullet">  -</span> Markdown</span><br><span class="line">categories: # 分类，可以有多个，通常是层级关系</span><br><span class="line"><span class="bullet">  -</span> 学习笔记</span><br><span class="line"><span class="bullet">  -</span> 博客搭建</span><br><span class="line">cover: /images/post<span class="emphasis">_cover.jpg # 可选，文章封面图片路径</span></span><br><span class="line"><span class="emphasis">description: 这是一篇关于如何发布Hexo文章的示例。 # 可选，文章摘要或描述</span></span><br><span class="line"><span class="emphasis">---</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 我的文章内容标题</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">这是我的文章正文内容，使用 Markdown 语法编写。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">你可以包含图片、代码块、列表等等。</span></span><br></pre></td></tr></table></figure></li><li><p>生成静态文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line"><span class="comment"># 或者简写</span></span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure></li><li><p>本地预览</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line"><span class="comment"># 或者简写</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></li><li><p>一键部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line"><span class="comment"># 或者简写</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ol><h2 id="更改或删除"><a href="#更改或删除" class="headerlink" title="更改或删除"></a>更改或删除</h2><p><strong>修改文章</strong>：直接打开 <code>source/_posts</code> 目录下的相应 Markdown 文件进行修改，保存后，再运行 <code>hexo generate</code> 和 <code>hexo deploy</code> 即可更新线上的文章。</p><p><strong>删除文章</strong>：如果你想彻底删除某篇文章，就从 <code>source/_posts</code> 目录中删除对应的 Markdown 文件。然后运行 <code>hexo clean</code> 清理旧的生成文件（可选，但推荐），接着运行 <code>hexo generate</code> 和 <code>hexo deploy</code>。这样，你的博客上这篇文章就会被移除。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客搭建 </tag>
            
            <tag> frontend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 项目工程化指南</title>
      <link href="/2025/06/02/backend-go/"/>
      <url>/2025/06/02/backend-go/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-项目工程化指南"><a href="#Go-项目工程化指南" class="headerlink" title="Go 项目工程化指南"></a>Go 项目工程化指南</h1><p>本文档旨在提供 Go 语言项目从零开始创建、管理依赖以及协作开发时可能遇到的工程性问题的解决方案。</p><h2 id="1-Go-项目的创建与初始化"><a href="#1-Go-项目的创建与初始化" class="headerlink" title="1. Go 项目的创建与初始化"></a>1. Go 项目的创建与初始化</h2><p>Go 语言的项目管理主要依赖于 Go Modules。从 Go 1.11 开始引入，并在 Go 1.16 成为默认。</p><h3 id="1-1-初始化一个新的-Go-Modules-项目"><a href="#1-1-初始化一个新的-Go-Modules-项目" class="headerlink" title="1.1 初始化一个新的 Go Modules 项目"></a>1.1 初始化一个新的 Go Modules 项目</h3><p>在你的工作目录下，创建一个新的项目文件夹，并进入该文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> my-go-project</span><br><span class="line"><span class="built_in">cd</span> my-go-project</span><br></pre></td></tr></table></figure><p>然后，运行 <code>go mod init</code> 命令来初始化 Go Module。这会在当前目录生成一个 <code>go.mod</code> 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init your_module_name <span class="comment"># 建议使用你的域名/用户名/项目名作为模块名，例如: github.com/your-username/my-go-project</span></span><br></pre></td></tr></table></figure><p><code>go.mod</code> 文件是 Go Modules 的核心，它定义了项目的模块路径、Go 版本以及项目的所有依赖。</p><h3 id="1-2-Go-项目基本结构"><a href="#1-2-Go-项目基本结构" class="headerlink" title="1.2 Go 项目基本结构"></a>1.2 Go 项目基本结构</h3><p>一个典型的 Go 项目结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">my-go-project/</span><br><span class="line">├── go.mod                <span class="comment"># 模块定义文件</span></span><br><span class="line">├── go.sum                <span class="comment"># 依赖校验和文件 (由 Go 自动维护，不要手动修改，始终随 go.mod 一起提交)</span></span><br><span class="line">├── main.go               <span class="comment"># 主程序入口文件 (如果项目只有一个入口点)</span></span><br><span class="line">├── config/               <span class="comment"># 配置文件目录，例如 config.json, application.yaml 等</span></span><br><span class="line">│   └── app.yaml</span><br><span class="line">├── internal/             <span class="comment"># 内部包，只能被当前模块内代码导入，不能被其他模块导入。</span></span><br><span class="line">│   ├── model/            <span class="comment"># 数据模型定义</span></span><br><span class="line">│   │   └── user.go</span><br><span class="line">│   └── service/          <span class="comment"># 业务逻辑服务</span></span><br><span class="line">│       └── user_service.go</span><br><span class="line">├── api/                  <span class="comment"># 外部接口定义，例如 RESTful API 接口定义，或者 Protobuf/Swagger 定义</span></span><br><span class="line">│   └── user_handler.go   <span class="comment"># API 路由及处理函数</span></span><br><span class="line">├── cmd/                  <span class="comment"># 包含多个主程序入口的目录，每个子目录代表一个可执行程序</span></span><br><span class="line">│   ├── web/              <span class="comment"># 例如：Web 服务器入口</span></span><br><span class="line">│   │   └── main.go</span><br><span class="line">│   └── cli/              <span class="comment"># 例如：命令行工具入口</span></span><br><span class="line">│       └── main.go</span><br><span class="line">├── pkg/                  <span class="comment"># 共享包，可以被当前模块和其他模块导入 (不常用，推荐 internal)</span></span><br><span class="line">│   └── utils/            <span class="comment"># 通用工具函数</span></span><br><span class="line">│       └── helper.go</span><br><span class="line">├── scripts/              <span class="comment"># 脚本文件，例如构建脚本、部署脚本等</span></span><br><span class="line">├── deployments/          <span class="comment"># 部署相关文件，例如 Kubernetes YAML，Ansible Playbooks</span></span><br><span class="line">├── tests/                <span class="comment"># 额外集成测试或性能测试 (与内部测试分开)</span></span><br><span class="line">├── .<span class="built_in">env</span>                  <span class="comment"># 环境变量文件 (敏感信息不提交 Git)</span></span><br><span class="line">├── Dockerfile            <span class="comment"># Docker 容器化文件</span></span><br><span class="line">├── README.md             <span class="comment"># 项目说明文档</span></span><br><span class="line">└── .gitignore            <span class="comment"># Git 忽略文件配置</span></span><br></pre></td></tr></table></figure><p><strong>关键点：</strong></p><ul><li><strong><code>go.mod</code></strong>: 模块定义文件，手动编辑或通过 <code>go get</code>、<code>go mod tidy</code> 等命令自动维护。</li><li><strong><code>go.sum</code></strong>: 记录了所有依赖的加密校验和，用于保证依赖的完整性和安全性。<strong>不要手动修改</strong>，始终随 <code>go.mod</code> 一起提交到版本控制。</li><li><strong><code>main.go</code></strong>: 通常是主程序的入口文件，如果项目简单只有一个可执行程序，可以放在根目录。如果项目包含多个可执行程序（如一个 Web 服务和一个命令行工具），则会将各自的 <code>main.go</code> 放在 <code>cmd/</code> 目录下的子目录中。</li><li><strong><code>internal/</code></strong>: 这是 Go 推荐的内部包存放位置。<code>internal</code> 目录下的包<strong>只能被当前模块内的代码导入和使用</strong>，不能被其他模块导入。这有助于限制包的可见性和职责。</li><li><strong><code>cmd/</code></strong>: 当你的项目包含多个独立的可执行文件时，这是组织它们的最佳实践。每个子目录都是一个独立的程序入口。例如，<code>cmd/web/main.go</code> 负责启动 Web 服务器，而 <code>cmd/cli/main.go</code> 负责启动一个命令行工具。</li></ul><h3 id="1-3-编译和打包成可执行文件"><a href="#1-3-编译和打包成可执行文件" class="headerlink" title="1.3 编译和打包成可执行文件"></a>1.3 编译和打包成可执行文件</h3><p>Go 语言提供了一个强大的 <code>go build</code> 命令，可以将你的 Go 源代码编译成独立的可执行二进制文件。</p><h4 id="1-3-1-基本编译"><a href="#1-3-1-基本编译" class="headerlink" title="1.3.1 基本编译"></a>1.3.1 基本编译</h4><p>在项目根目录下（<code>my-go-project/</code>）：</p><ul><li><p><strong>如果你的主程序入口是 <code>main.go</code> (在项目根目录)：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -o myapp .</span><br></pre></td></tr></table></figure><p>这条命令会编译当前目录下的 Go 源代码，并生成一个名为 <code>myapp</code> 的可执行文件。在 Windows 上会是 <code>myapp.exe</code>。</p></li><li><p><strong>如果你的主程序入口在 <code>cmd/</code> 目录下 (例如 <code>cmd/web/main.go</code>)：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -o myweb_app ./cmd/web</span><br></pre></td></tr></table></figure><p>这条命令会编译 <code>cmd/web</code> 目录下的 Go 源代码，并生成一个名为 <code>myweb_app</code> 的可执行文件。</p></li></ul><p>编译完成后，你会在当前目录（或者你指定的输出目录）找到这个可执行文件。你可以直接运行它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./myapp <span class="comment"># Linux/macOS</span></span><br><span class="line">.\myapp.exe <span class="comment"># Windows</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./myweb_app <span class="comment"># Linux/macOS</span></span><br><span class="line">.\myweb_app.exe <span class="comment"># Windows</span></span><br></pre></td></tr></table></figure><h4 id="1-3-2-交叉编译-Cross-Compilation"><a href="#1-3-2-交叉编译-Cross-Compilation" class="headerlink" title="1.3.2 交叉编译 (Cross-Compilation)"></a>1.3.2 交叉编译 (Cross-Compilation)</h4><p>Go 语言的强大之处在于其天生支持交叉编译，这意味着你可以在一个操作系统上编译出在另一个操作系统上运行的可执行文件，而无需安装目标平台的 Go 环境。</p><p>通过设置 <code>GOOS</code> (目标操作系统) 和 <code>GOARCH</code> (目标架构) 环境变量来实现：</p><p><strong>常用组合：</strong></p><ul><li><p><strong>Linux (64-bit AMD)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOOS=linux GOARCH=amd64 go build -o myapp_linux_amd64 .</span><br></pre></td></tr></table></figure></li><li><p><strong>Windows (64-bit AMD)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOOS=windows GOARCH=amd64 go build -o myapp_windows_amd64.exe .</span><br></pre></td></tr></table></figure></li><li><p><strong>macOS (64-bit Intel)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOOS=darwin GOARCH=amd64 go build -o myapp_darwin_amd64 .</span><br></pre></td></tr></table></figure></li><li><p><strong>macOS (ARM64 &#x2F; Apple Silicon)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOOS=darwin GOARCH=arm64 go build -o myapp_darwin_arm64 .</span><br></pre></td></tr></table></figure></li><li><p><strong>Linux (ARM64)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOOS=linux GOARCH=arm64 go build -o myapp_linux_arm64 .</span><br></pre></td></tr></table></figure></li></ul><p><strong>完整的 <code>GOOS</code> 和 <code>GOARCH</code> 列表，请运行：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool dist list</span><br></pre></td></tr></table></figure><h4 id="1-3-3-减小可执行文件大小"><a href="#1-3-3-减小可执行文件大小" class="headerlink" title="1.3.3 减小可执行文件大小"></a>1.3.3 减小可执行文件大小</h4><p>对于生产环境部署，你可能希望减小可执行文件的大小。可以使用 <code>-ldflags</code> 编译标志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -o myapp -ldflags <span class="string">&quot;-s -w&quot;</span> .</span><br></pre></td></tr></table></figure><ul><li><code>-s</code>: 移除符号表（debug information）。</li><li><code>-w</code>: 移除 DWARF 调试信息。</li></ul><p>这会显著减小二进制文件大小，但也会使调试变得困难。</p><h4 id="1-3-4-生成静态链接的二进制文件-推荐用于-Docker"><a href="#1-3-4-生成静态链接的二进制文件-推荐用于-Docker" class="headerlink" title="1.3.4 生成静态链接的二进制文件 (推荐用于 Docker)"></a>1.3.4 生成静态链接的二进制文件 (推荐用于 Docker)</h4><p>如果你的 Go 程序使用了 CGO (例如，某些数据库驱动或图像处理库)，生成的二进制文件可能会依赖系统上的 C 库。为了生成完全独立的二进制文件（特别适合 Docker 镜像），可以禁用 CGO：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o myapp_static_linux -ldflags <span class="string">&quot;-s -w&quot;</span> .</span><br></pre></td></tr></table></figure><ul><li><code>CGO_ENABLED=0</code>: 禁用 CGO。</li><li><code>GOOS=linux GOARCH=amd64</code>: 确保编译目标是 Linux AMD64，这是大多数生产环境 Docker 容器的默认环境。</li></ul><p>这会生成一个完全静态链接的二进制文件，不依赖目标系统的任何 C 库，非常适合构建轻量级的 Docker 镜像 (例如基于 <code>scratch</code> 或 <code>alpine</code> 的镜像)。</p><h2 id="2-依赖管理"><a href="#2-依赖管理" class="headerlink" title="2. 依赖管理"></a>2. 依赖管理</h2><p>Go Modules 让依赖管理变得非常简单。</p><h3 id="2-1-添加新的依赖"><a href="#2-1-添加新的依赖" class="headerlink" title="2.1 添加新的依赖"></a>2.1 添加新的依赖</h3><p>当你需要引入一个新的第三方库时，可以在代码中直接 <code>import</code> 它。然后，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/gin-gonic/gin <span class="comment"># 将 gin 框架添加到你的项目中</span></span><br></pre></td></tr></table></figure><p>或者，你也可以只在代码中 <code>import</code> 新的包，然后运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy <span class="comment"># Go 会自动分析代码，下载所有缺失的依赖，并清理不再使用的依赖</span></span><br></pre></td></tr></table></figure><p>这两种方式都会更新 <code>go.mod</code> 和 <code>go.sum</code> 文件。</p><h3 id="2-2-更新现有依赖"><a href="#2-2-更新现有依赖" class="headerlink" title="2.2 更新现有依赖"></a>2.2 更新现有依赖</h3><p>要将某个依赖更新到最新版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin <span class="comment"># 更新到最新的兼容版本</span></span><br><span class="line">go get -u=patch github.com/gin-gonic/gin <span class="comment"># 只更新到最新的补丁版本</span></span><br><span class="line">go get github.com/gin-gonic/gin@v1.7.0 <span class="comment"># 更新到指定版本</span></span><br></pre></td></tr></table></figure><h3 id="2-3-移除不再使用的依赖"><a href="#2-3-移除不再使用的依赖" class="headerlink" title="2.3 移除不再使用的依赖"></a>2.3 移除不再使用的依赖</h3><p>如果你的代码不再使用某个依赖，<code>go mod tidy</code> 命令会自动帮你清理 <code>go.mod</code> 和 <code>go.sum</code> 文件中的相关条目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><h3 id="2-4-查看依赖图"><a href="#2-4-查看依赖图" class="headerlink" title="2.4 查看依赖图"></a>2.4 查看依赖图</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod graph <span class="comment"># 显示模块依赖图</span></span><br></pre></td></tr></table></figure><h3 id="2-5-供应商模式-Vendor-Mode"><a href="#2-5-供应商模式-Vendor-Mode" class="headerlink" title="2.5 供应商模式 (Vendor Mode)"></a>2.5 供应商模式 (Vendor Mode)</h3><p>在某些特定场景下（例如，网络环境受限、严格的依赖版本控制），你可能希望将所有依赖的源代码复制到项目本地的 <code>vendor</code> 目录中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod vendor</span><br></pre></td></tr></table></figure><p>这会在项目根目录创建一个 <code>vendor</code> 文件夹，包含所有依赖的源代码。</p><ul><li><p>启用 vendor 模式编译:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go build -mod=vendor</span><br><span class="line">go run -mod=vendor .</span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>: 默认情况下，Go 会优先使用 Go Modules Proxy 进行依赖下载。只有在显式指定 <code>-mod=vendor</code> 时，或者在 Go Modules Proxy 不可用的情况下，才会使用 <code>vendor</code> 目录。对于大多数现代 Go 项目，不建议默认使用 <code>vendor</code> 模式，直接依赖 Go Modules Proxy 更简单。</p></li></ul><h2 id="3-拉取别人的-Go-项目并下载依赖"><a href="#3-拉取别人的-Go-项目并下载依赖" class="headerlink" title="3. 拉取别人的 Go 项目并下载依赖"></a>3. 拉取别人的 Go 项目并下载依赖</h2><p>当你 <code>git clone</code> 了一个 Go 项目后，安装其依赖通常非常简单。</p><h3 id="3-1-克隆项目"><a href="#3-1-克隆项目" class="headerlink" title="3.1 克隆项目"></a>3.1 克隆项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/some-user/some-go-project.git</span><br><span class="line"><span class="built_in">cd</span> some-go-project</span><br></pre></td></tr></table></figure><h3 id="3-2-下载并安装依赖"><a href="#3-2-下载并安装依赖" class="headerlink" title="3.2 下载并安装依赖"></a>3.2 下载并安装依赖</h3><p>进入项目根目录（即 <code>go.mod</code> 文件所在的目录），然后运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><p>这个命令会执行以下操作：</p><ol><li><strong>读取 <code>go.mod</code></strong>: 解析项目所需的模块及其版本。</li><li><strong>下载模块</strong>: 如果本地 Go Module 缓存中没有这些模块，它会从 Go Modules Proxy（默认是 <code>proxy.golang.org</code>，在国内可能需要配置代理）下载。</li><li><strong>验证校验和</strong>: 检查 <code>go.sum</code> 文件中记录的校验和，确保下载的模块没有被篡改。</li><li><strong>清理</strong>: 如果代码中不再使用的依赖，会从 <code>go.mod</code> 和 <code>go.sum</code> 中移除。</li></ol><p><strong>这是最推荐和最常用的方法。</strong></p><h3 id="3-3-编译和运行项目"><a href="#3-3-编译和运行项目" class="headerlink" title="3.3 编译和运行项目"></a>3.3 编译和运行项目</h3><p>在依赖下载完成后，你可以直接编译或运行项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go build .       <span class="comment"># 编译当前目录下的 Go 项目，生成可执行文件</span></span><br><span class="line">./your_executable <span class="comment"># 运行编译后的可执行文件</span></span><br><span class="line"></span><br><span class="line">go run .         <span class="comment"># 直接运行当前目录下的 Go 项目 (不会生成可执行文件)</span></span><br></pre></td></tr></table></figure><p>如果项目有多个命令行入口（例如 <code>cmd/</code> 目录），你需要指定要运行的入口文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run ./cmd/mycli</span><br></pre></td></tr></table></figure><h3 id="3-4-处理网络代理问题"><a href="#3-4-处理网络代理问题" class="headerlink" title="3.4 处理网络代理问题"></a>3.4 处理网络代理问题</h3><p>在中国大陆地区，访问 <code>proxy.golang.org</code> 或一些 GitHub 上的 Go 模块可能会遇到网络问题。你可以设置 Go 代理：</p><p><strong>临时设置：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><p><strong>永久设置（推荐加入到 <code>~/.bashrc</code>, <code>~/.zshrc</code> 或 <code>~/.profile</code> 中）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><p>这将把 <code>GOPROXY</code> 设置为国内的 Go 模块代理 <code>goproxy.cn</code>。<code>direct</code> 表示如果代理失败，尝试直接连接。</p><h3 id="3-5-处理私有仓库依赖"><a href="#3-5-处理私有仓库依赖" class="headerlink" title="3.5 处理私有仓库依赖"></a>3.5 处理私有仓库依赖</h3><p>如果项目依赖了私有 Git 仓库（例如公司内部的 GitLab 仓库），Go 可能无法直接下载。你需要配置 <code>GOPRIVATE</code> 或 <code>GONOPROXY</code>&#x2F;<code>GONOSUM</code>。</p><p><strong><code>GOPRIVATE</code></strong>: 告诉 Go 哪些模块是私有的，不要通过公共代理去查找。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GOPRIVATE=git.example.com/* <span class="comment"># 假设你的私有仓库都在 git.example.com 下</span></span><br></pre></td></tr></table></figure><p>Go 在处理 <code>GOPRIVATE</code> 中定义的模块时，会直接从版本控制系统（如 Git）拉取，而不是通过 <code>GOPROXY</code>。这意味着你需要确保 Git 客户端配置了正确的认证方式（例如 SSH 密钥或用户名&#x2F;密码）。</p><h2 id="4-常见的工程化问题与解决方案"><a href="#4-常见的工程化问题与解决方案" class="headerlink" title="4. 常见的工程化问题与解决方案"></a>4. 常见的工程化问题与解决方案</h2><h3 id="4-1-解决依赖版本冲突"><a href="#4-1-解决依赖版本冲突" class="headerlink" title="4.1 解决依赖版本冲突"></a>4.1 解决依赖版本冲突</h3><p>当两个依赖包共同依赖于同一个第三方包，但要求不同版本时，可能会发生冲突。</p><ul><li><p><strong><code>go mod tidy</code></strong>: 优先尝试运行 <code>go mod tidy</code>。Go Modules 的最小版本选择 (MVS) 算法通常能很好地解决冲突，它会选择所有依赖方都满足的最低兼容版本。</p></li><li><p>手动调整 <code>go.mod</code>:  <code>go mod tidy</code> 如果无法解决，你可以手动在 <code>go.mod</code>中使用 <code>require</code>指令明确指定一个版本，或者使用 <code>replace</code>指令替换掉某个模块。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go.mod 示例</span></span><br><span class="line">module my-<span class="keyword">go</span>-project</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.22</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/gin-gonic/gin v1<span class="number">.9</span><span class="number">.0</span></span><br><span class="line">    github.com/spf13/viper v1<span class="number">.11</span><span class="number">.0</span> <span class="comment">// 假设冲突，你需要指定这个版本</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换本地模块 (用于开发或测试)</span></span><br><span class="line"><span class="comment">// replace example.com/my/local/module =&gt; ../my/local/module</span></span><br><span class="line"><span class="comment">// 替换远程模块 (例如，修复了上游 bug)</span></span><br><span class="line"><span class="comment">// replace github.com/old/module v1.2.3 =&gt; github.com/new/module v1.2.4</span></span><br></pre></td></tr></table></figure><p>注意: <code>replace</code> 指令通常只在开发环境中或为了解决特定问题时使用，不建议大量用于生产环境，因为它可能导致构建环境不一致。</p></li></ul><h3 id="4-2-跨平台编译"><a href="#4-2-跨平台编译" class="headerlink" title="4.2 跨平台编译"></a>4.2 跨平台编译</h3><p>Go 语言支持轻松地进行交叉编译。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译 Linux 64-bit 可执行文件</span></span><br><span class="line">GOOS=linux GOARCH=amd64 go build -o myapp_linux_amd64 .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 Windows 64-bit 可执行文件</span></span><br><span class="line">GOOS=windows GOARCH=amd64 go build -o myapp_windows_amd64.exe .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 macOS ARM64 (Apple Silicon) 可执行文件</span></span><br><span class="line">GOOS=darwin GOARCH=arm64 go build -o myapp_darwin_arm64 .</span><br></pre></td></tr></table></figure><p><code>GOOS</code> 和 <code>GOARCH</code> 是 Go 环境变量，分别指定目标操作系统和架构。</p><h3 id="4-3-代码风格检查与格式化"><a href="#4-3-代码风格检查与格式化" class="headerlink" title="4.3 代码风格检查与格式化"></a>4.3 代码风格检查与格式化</h3><p>Go 社区有强大的工具来强制一致的代码风格。</p><ul><li><p><strong><code>go fmt</code></strong>: 格式化代码，使所有代码符合 Go 官方风格。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">fmt</span> ./... <span class="comment"># 格式化当前模块所有 Go 文件</span></span><br></pre></td></tr></table></figure><p>建议在提交代码前执行此命令。大多数 IDE (如 GoLand, VS Code) 都会在保存时自动运行 <code>go fmt</code>。</p></li><li><p><strong><code>golint</code> (已弃用，推荐 <code>staticcheck</code>)</strong>: 静态代码分析工具，用于检查潜在的代码问题和风格建议。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get golang.org/x/lint/golint <span class="comment"># 如果没有安装</span></span><br><span class="line">golint ./...</span><br></pre></td></tr></table></figure><p><strong>注意：<code>golint</code> 已经不再维护，推荐使用 <code>staticcheck</code>。</strong></p></li><li><p><strong><code>staticcheck</code></strong>: 更强大的静态分析工具集。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go install honnef.co/go/tools/cmd/staticcheck@latest <span class="comment"># 安装</span></span><br><span class="line">staticcheck ./...</span><br></pre></td></tr></table></figure><p>建议在 CI&#x2F;CD 流程中集成 <code>staticcheck</code>。</p></li></ul><h3 id="4-4-单元测试与集成测试"><a href="#4-4-单元测试与集成测试" class="headerlink" title="4.4 单元测试与集成测试"></a>4.4 单元测试与集成测试</h3><p>Go 内置了测试框架。</p><ul><li><p><strong>编写测试</strong>: 在与 Go 源文件同级的目录下创建 <code>_test.go</code> 文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_package_test.go</span></span><br><span class="line"><span class="keyword">package</span> my_package</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMyFunction</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ... 测试逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>运行测试</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> ./... <span class="comment"># 运行当前模块所有测试</span></span><br><span class="line">go <span class="built_in">test</span> -v ./... <span class="comment"># 详细输出测试结果</span></span><br><span class="line">go <span class="built_in">test</span> -cover ./... <span class="comment"># 运行测试并生成代码覆盖率报告</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-5-Git-版本控制最佳实践"><a href="#4-5-Git-版本控制最佳实践" class="headerlink" title="4.5 Git 版本控制最佳实践"></a>4.5 Git 版本控制最佳实践</h3><ul><li><p><strong>始终提交 <code>go.mod</code> 和 <code>go.sum</code></strong>: 它们定义了项目的依赖，必须和代码一起版本控制。</p></li><li><p>使用 <code>.gitignore</code>: 忽略编译生成的可执行文件、临时文件、编辑器生成的文件等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Binaries for programs and plugins</span><br><span class="line">*.exe</span><br><span class="line">*.dll</span><br><span class="line">*.so</span><br><span class="line">*.dylib</span><br><span class="line">*.rpm</span><br><span class="line">*.deb</span><br><span class="line">*.ko</span><br><span class="line"></span><br><span class="line"># Test binary, generated with `go test -c`</span><br><span class="line">*.test</span><br><span class="line"></span><br><span class="line"># Output of the go toolchain when building a test binary using stubs (race detector, cgo)</span><br><span class="line">*.out</span><br><span class="line"></span><br><span class="line"># External tool specific artifacts</span><br><span class="line">.idea/ # GoLand IDE files</span><br><span class="line">.vscode/ # VS Code IDE files</span><br><span class="line">.DS_Store</span><br><span class="line"></span><br><span class="line"># Dependencies (vendor folder)</span><br><span class="line"># vendor/ # 如果不使用 vendor 模式，可以不忽略</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-6-Docker-化-Go-应用"><a href="#4-6-Docker-化-Go-应用" class="headerlink" title="4.6 Docker 化 Go 应用"></a>4.6 Docker 化 Go 应用</h3><p>将 Go 应用打包成 Docker 镜像以方便部署。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile 示例 (多阶段构建)</span></span><br><span class="line"><span class="comment"># 阶段 1: 构建</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.22</span> AS builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝 go.mod 和 go.sum 以利用 Docker 缓存</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> go.mod go.sum ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go mod download</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝源代码</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译应用</span></span><br><span class="line"><span class="comment"># CGO_ENABLED=0 是为了生成静态链接的可执行文件，更易于分发</span></span><br><span class="line"><span class="comment"># -a 强制重新编译所有包</span></span><br><span class="line"><span class="comment"># -installsuffix cgo 解决 cgo 静态链接问题</span></span><br><span class="line"><span class="comment"># -ldflags &quot;-s -w&quot; 移除调试信息和符号表，减小镜像大小</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -ldflags <span class="string">&quot;-s -w&quot;</span> -o main ./cmd/your_app <span class="comment"># 根据你的入口调整</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 阶段 2: 运行</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从构建阶段复制可执行文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /app/main .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口 (如果你的应用是 Web 服务)</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行应用</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./main&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>构建 Docker 镜像：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-go-app .</span><br></pre></td></tr></table></figure><p><strong>运行 Docker 容器：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 my-go-app</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过遵循这些 Go 项目工程化指南，你将能够更高效、更规范地创建、维护和协作 Go 语言项目。良好的工程实践是保证项目质量和长期可维护性的关键。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Backend </tag>
            
            <tag> Go </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我</title>
      <link href="/2025/03/15/hello-world/"/>
      <url>/2025/03/15/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="你好，我是-Leonardo-King！"><a href="#你好，我是-Leonardo-King！" class="headerlink" title="你好，我是 Leonardo King！"></a>你好，我是 Leonardo King！</h1><p>很高兴你能来到我的博客！在这里，我想简单介绍一下自己。</p><p>我是一名<strong>软件工程</strong>专业的大学生，目前正沉浸在代码的世界里，努力学习各种软件开发知识，希望能成为一名优秀的开发者。</p><h2 id="我的学习旅程"><a href="#我的学习旅程" class="headerlink" title="我的学习旅程"></a>我的学习旅程</h2><p>在大学期间，我积极探索着在深入学习 <strong>Vue.js</strong> 框架，享受着将设计稿变为互动界面的乐趣。在<strong>后端</strong>方面，我正尝试使用 <strong>Gin 框架</strong>进行实践，学习软件开发的各个领域。我对<strong>全栈开发</strong>充满热情，目前正习如何构建高效稳定的服务。</p><p>当然，我的学习之路远不止于此。我掌握了 <strong>Java、Python、C&#x2F;C++</strong> 等编程语言的基本使用，它们是我解决问题和实现创意的基础工具。通过这些语言，我尝试过数据结构与算法、小型项目开发等，不断巩固自己的编程能力。</p><h2 id="为什么建立这个博客？"><a href="#为什么建立这个博客？" class="headerlink" title="为什么建立这个博客？"></a>为什么建立这个博客？</h2><p>建立这个博客，是希望能够记录下我的学习过程、遇到的问题以及解决方案，也会分享一些供学习使用的资源和工具，希望能对你们有所帮助。我相信，通过分享和总结，能让我对知识有更深刻的理解。同时，也期待能与志同道合的朋友们一起交流、共同进步！</p><h2 id="期待与你共同进步！"><a href="#期待与你共同进步！" class="headerlink" title="期待与你共同进步！"></a>期待与你共同进步！</h2><p>无论是前端的酷炫特效，后端的稳定架构，还是算法的精妙设计，我都保持着好奇心和学习的热情。如果你对软件开发也有兴趣，或者有任何建议和想法，欢迎随时留言或与我联系。让我们一起在技术的世界里探索、成长！</p><p>感谢你的阅读！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
